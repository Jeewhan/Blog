<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Pragmatic Programmer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://JeewhanR.github.io/"/>
  <updated>2018-04-30T18:04:12.586Z</updated>
  <id>https://JeewhanR.github.io/</id>
  
  <author>
    <name>Jeewhan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>괜찮아 ! 너만 모르는 건 아니야 - 어휘편</title>
    <link href="https://JeewhanR.github.io/2018/05/01/2018-05-01-ok-word/"/>
    <id>https://JeewhanR.github.io/2018/05/01/2018-05-01-ok-word/</id>
    <published>2018-04-30T15:26:15.474Z</published>
    <updated>2018-04-30T18:04:12.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="괜찮아-너만-모르는-건-아니야-어휘편"><a href="#괜찮아-너만-모르는-건-아니야-어휘편" class="headerlink" title="괜찮아 ! 너만 모르는 건 아니야 - 어휘편"></a>괜찮아 ! 너만 모르는 건 아니야 - 어휘편</h1><h2 id="OT"><a href="#OT" class="headerlink" title="OT"></a>OT</h2><h3 id="1-생각의-틀을-확장하라"><a href="#1-생각의-틀을-확장하라" class="headerlink" title="1. 생각의 틀을 확장하라"></a>1. 생각의 틀을 확장하라</h3><p>붙다 라는 한국어를 미국인이 공부한다고 생각해보자</p><ol><li>stick</li></ol><ul><li>머리에 껌 붙었다.</li></ul><ol start="2"><li>pass</li></ol><ul><li>너 시험에 붙었다며?</li></ul><ol start="3"><li>take side</li></ol><ul><li>그 사람은 반대파에 붙었다</li></ul><ol start="4"><li>live with</li></ol><ul><li>그는 그 나이가 되도록 엄마에게 붙어산다</li></ul><p>위에 있는 붙다는 약간씩 의미가 다르긴 하지만, 큰 틀에서 모두 같은 말이다</p><p>위 단어를 평소 한국인이 영어를 공부하듯이 1번 또는 2번 정도까지만 암기하고 넘어간다면, 아래와 같은 문제는 해결할 수 없게 된다</p><p>하나의 기준을 정확히 마련해놓지 않은 채로, 우화 속의 박쥐처럼 상황에 따라 자신에게 유리한 편을 드는 사람을 한국에서는 <code>간에 ____ 쓸개에 ____ 한다</code> 라고 한다</p><h3 id="2-기본-의미-확장-훈련"><a href="#2-기본-의미-확장-훈련" class="headerlink" title="2. 기본 의미 확장 훈련"></a>2. 기본 의미 확장 훈련</h3><p>단어의 의미는 하나일 수 없다 (학술적으로 사용되는 명사의 경우 제외)</p><p>따라서 일대일 대응으로 단어를 학습해서는 제대로 학습할 수 없다</p><p>대부분의 학습자는 general을 일반적인 이라는 의미로 암기한다, 그렇게 할 경우 어떤 문제가 생기는지 살펴보자</p><p>general hospital : 일반 병원<br>general strike : 일반 파업<br>general anesthesia : 일반 마취<br>general attack : 일반 공격<br>general meeting : 일반 모임<br>general election : 일반 선거<br>general truce : 일반 휴전<br>general cleaning : 일반 청소<br>general denial : 일반적 부인</p><p>general이라는 단어의 전체적인 모습은 다음과 같다</p><ol><li>affecting all or most people, places or things</li><li>not limited to a particular aspect of a person or thing</li></ol><p>즉 한 가지 면에만 국한되지 않는, 대부분의 사람, 장소, 사물에 두루 영향을 미치는 이런 이미지를 가지고 있는 단어이다</p><p>따라서 유의해야 할 점은 general의 의미를 일반적인, 전면적인, 포괄적인 이런 식으로 다의어처럼 외우면 안 된다는 것이다</p><p>위의 이미지처럼 이해하자, 그러면 아래와 같은 의미가 된다</p><p>general hospital : 종합 병원<br>general strike : 총파업<br>general anesthesia : 전신 마취<br>general attack : 총공격<br>general meeting : 총회<br>general election : 총선거<br>general truce : 전면 휴전<br>general cleaning : 대청소<br>general denial : 전면 부인</p><p>bring up 이라는 단어를 기르다 로 외운다면 아래 문장을 제대로 해석할 수 없다</p><p>She brought up what she had for lunch</p><p>bring up 은 위로 가져오(가)다 로 이해되어야 한다</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;괜찮아-너만-모르는-건-아니야-어휘편&quot;&gt;&lt;a href=&quot;#괜찮아-너만-모르는-건-아니야-어휘편&quot; class=&quot;headerlink&quot; title=&quot;괜찮아 ! 너만 모르는 건 아니야 - 어휘편&quot;&gt;&lt;/a&gt;괜찮아 ! 너만 모르는 건 아니야 - 어
      
    
    </summary>
    
      <category term="English" scheme="https://JeewhanR.github.io/categories/English/"/>
    
    
      <category term="English" scheme="https://JeewhanR.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title> 빅오표기법</title>
    <link href="https://JeewhanR.github.io/2018/04/30/2018-03-12-BigO/"/>
    <id>https://JeewhanR.github.io/2018/04/30/2018-03-12-BigO/</id>
    <published>2018-04-29T15:55:42.666Z</published>
    <updated>2018-04-30T17:58:28.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실용적인-알고리즘-1-빅오표기법"><a href="#실용적인-알고리즘-1-빅오표기법" class="headerlink" title="실용적인 알고리즘 (1) - 빅오표기법"></a>실용적인 알고리즘 (1) - 빅오표기법</h1><p><a href="https://www.youtube.com/watch?v=6Iq5iMCVsXA" target="_blank" rel="noopener">빅오(Big-O)표기법 완전정복</a></p><p><img src="http://www.jidum.com/upload/ckeditor/2016/09/2016090909541455.jpg" alt="img"></p><p>알고리즘의 성능을 수학적으로 표시해주는 표기법</p><p>실제 수행시간보다는 데이터의 증가에 따른 증가량을 예측하는 것에 목적을 두므로 상수는 모두 버린다</p><table><thead><tr><th>BigO</th><th>설명</th></tr></thead><tbody><tr><td>O(1)</td><td>입력 데이터와 무관하게 일정한 시간이 소요됨</td></tr><tr><td>O(N)</td><td>입력 데이터에 비례해서 처리시간이 소요됨</td></tr><tr><td>O(N^2)</td><td>N개의 데이터를 받으면 각각의 아이템마다 N번의 연산을 수행함</td></tr><tr><td>O(NM)</td><td>N과 M의 변수가 다르다면 N^2과는 분명하게 차이가 존재함, 증가에 따른 변화율은 N^2과 동일</td></tr><tr><td>O(N^3)</td><td>데이터의 증가에 따라 더 급격한 증가</td></tr><tr><td>O(2^N)</td><td>피보나치 수열, N^3보다도 현저한 증가</td></tr><tr><td>O(logN)</td><td>이진검색이 대표적 사례</td></tr><tr><td>O(sqrt(N))</td><td>정사각형을 만들어서 맨 위의 한 줄이 제곱근</td></tr></tbody></table><p>피보나치 나선형</p><p><img src="http://roulettegeeks.com/wp-content/uploads/2015/09/Fibonacci-Roulette-System.jpg" alt="img"></p><p>상수는 과감히 버린다, 상수는 데이터의 증가에 대해 상수만큼만 영향을 미치므로 증가하지 않는 숫자는 무시한다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;실용적인-알고리즘-1-빅오표기법&quot;&gt;&lt;a href=&quot;#실용적인-알고리즘-1-빅오표기법&quot; class=&quot;headerlink&quot; title=&quot;실용적인 알고리즘 (1) - 빅오표기법&quot;&gt;&lt;/a&gt;실용적인 알고리즘 (1) - 빅오표기법&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>React Fundamental</title>
    <link href="https://JeewhanR.github.io/2018/04/22/2018-04-22-React-Fundamental/"/>
    <id>https://JeewhanR.github.io/2018/04/22/2018-04-22-React-Fundamental/</id>
    <published>2018-04-21T15:17:19.964Z</published>
    <updated>2018-04-30T18:02:58.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-React"><a href="#Why-React" class="headerlink" title="Why React?"></a>Why React?</h1><p>Composition Model</p><ul><li>A good function should follow the “Do One Thing” rule</li><li>When you combine these simple functions together to form a more complex function, this is <strong>composition</strong>.</li><li><a href="https://www.linkedin.com/pulse/compose-me-function-composition-javascript-kevin-greene/" target="_blank" rel="noopener">Compose me That: Function Composition in JavaScript</a></li><li><a href="https://hackernoon.com/javascript-functional-composition-for-every-day-use-22421ef65a10" target="_blank" rel="noopener">Functional JavaScript: Function lComposition For Every Day Use.</a></li></ul><p>Declarative Code</p><ul><li>When JavaScript code is written <em>imperatively</em>, we tell JavaScript exactly <strong>what</strong> to do and <strong>how</strong> to do it. Think of it as if we’re giving JavaScript <em>commands</em> on exactly what steps it should take.</li><li>we <em>declare</em> what we want done, and JavaScript will take care of doing it.</li><li><em>Imperative</em> code instructs JavaScript on <em>how</em> it should perform each step. With <em>declarative</em> code, we tell JavaScript <em>what</em> we want to be done, and let JavaScript take care of performing the steps.</li><li><a href="https://tylermcginnis.com/imperative-vs-declarative-programming/" target="_blank" rel="noopener">Imperative vs Declarative Programming</a></li><li><a href="https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js" target="_blank" rel="noopener">Difference between declarative and imperative in React.js?</a> from StackOverflow</li></ul><p>Unidirectional Data Flow</p><ul><li><em>Data flows down from parent component to child component. Data updates are sent to the parent component where the parent performs the actual change.</em> this might seem like extra work, but having the data flow in one direction and having one place where the data is modified makes it much easier to understand how the application works.</li><li>In React, data flows in only one direction, from parent to child. If data is shared between sibling child components, then the data should be stored in the parent component and passed to both of the child components that need it.</li></ul><p>Just JavaScript</p><ul><li>Why not look through some of your existing code and try converting your <code>for</code> loops to <code>.map()</code> calls or see if you can remove any <code>if</code> statements by using <code>.filter()</code>.</li></ul><h1 id="Rendering-UI-with-React"><a href="#Rendering-UI-with-React" class="headerlink" title="Rendering UI with React"></a>Rendering UI with React</h1><p>Creating Elements and JSX</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement( <span class="comment">/* type */</span>, <span class="comment">/* props */</span>, <span class="comment">/* content */</span> );</span><br></pre></td></tr></table></figure></li><li><p>Let’s break down what each item can be:</p><ul><li><p><code>type</code> – either a string or a React Component</p><p>This can be a string of any existing HTML element (e.g. <code>&#39;p&#39;</code>, <code>&#39;span&#39;</code>, or <code>&#39;header&#39;</code>) or you could pass a React <em>component</em> (we’ll be creating components with JSX, in just a moment).</p></li></ul></li></ul><ul><li><p><code>props</code> – either <code>null</code> or an object</p><p>This is an object of HTML attributes and custom data about the element.</p></li></ul><ul><li><p><code>content</code> – <code>null</code>, a string, a React Element, or a React Component</p><p>Anything that you pass here will be the content of the rendered element. This can include plain text, JavaScript code, other React elements, etc.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Why-React&quot;&gt;&lt;a href=&quot;#Why-React&quot; class=&quot;headerlink&quot; title=&quot;Why React?&quot;&gt;&lt;/a&gt;Why React?&lt;/h1&gt;&lt;p&gt;Composition Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A good fu
      
    
    </summary>
    
      <category term="React" scheme="https://JeewhanR.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://JeewhanR.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>배열과 문자열</title>
    <link href="https://JeewhanR.github.io/2018/03/24/2018-04-23-Array-String/"/>
    <id>https://JeewhanR.github.io/2018/03/24/2018-04-23-Array-String/</id>
    <published>2018-03-24T05:17:03.707Z</published>
    <updated>2018-04-30T18:04:47.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코딩인터뷰-완전-분석-배열과-문자열"><a href="#코딩인터뷰-완전-분석-배열과-문자열" class="headerlink" title="코딩인터뷰 완전 분석 - 배열과 문자열"></a>코딩인터뷰 완전 분석 - 배열과 문자열</h1><h2 id="해시테이블"><a href="#해시테이블" class="headerlink" title="해시테이블"></a>해시테이블</h2><p>효율적인 탐색을 위해 key를 value에 대응시킨 자료구조</p><p>연결리스트와 해시 코드 함수를 통해 구현 가능</p><p>키와 값을 해시테이블에 넣을 때는 다음의 과정을 거친다<br>(키는 무한한데, 키의 자료형인 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 인덱스를 가리킬 수도 있다, 연결리스트를 이용하는 이유는 서로 다른 두 개의 키가 같은 해시 코드 또는 서로 다른 두 개의 해시 코드가 같은 인덱스를 가리키는 충돌에 대비하기 위해서이다)</p><ol><li>주어진 키의 해시 코드를 계산</li><li>해시 코드를 이용해 배열의 인덱스를 구한다 (hash(key) % array_length 와 같은 방식)</li><li>배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트에서 키에 상응하는 값을 탐색</li></ol><p>충돌이 자주 발생한다면, worst case runtime은 O(N)이 된다</p><p>일반적으로는 충돌이 최소화된 경우를 가정하는데 이 경우에는 O(1)</p><p><img src="https://user-images.githubusercontent.com/14256139/39124151-56f1a7ea-4735-11e8-843d-3a03d3598246.png" alt="img"></p><p>균형 이진 탐색 트리로도 구현할 수 있으며, 이 경우에는 O(logN)이 된다고 한다, TODO</p><h2 id="ArrayList와-가변-크기-배열"><a href="#ArrayList와-가변-크기-배열" class="headerlink" title="ArrayList와 가변 크기 배열"></a>ArrayList와 가변 크기 배열</h2><p>Java와 같이 배열의 길이가 고정되어 있는 언어에서 길이가 동적으로 변하는 자료구조가 필요할 때 사용한다</p><p>통상적으로 배열이 가득 차는 순간, 기존 배열의 크기를 두 배로 늘린다,<br>이 때는 O(N)이지만 자주 발생하는 상황이 아니므로 각 삽입은 평균적으로 O(1)이 소요된다</p><h2 id="String-Builder"><a href="#String-Builder" class="headerlink" title="String Builder"></a>String Builder</h2><p>ArrayList, StringBuilder 모두 array를 들고 있다</p><p>처음에 기본적으로 ArrayList는 크기 5개 짜리 array를, StringBuilder는 16개 짜리를 만든다</p><p>둘 모두 배열의 용량이 가득 차면 Capacity를 두 배로 늘리는 동작을 수행한다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;코딩인터뷰-완전-분석-배열과-문자열&quot;&gt;&lt;a href=&quot;#코딩인터뷰-완전-분석-배열과-문자열&quot; class=&quot;headerlink&quot; title=&quot;코딩인터뷰 완전 분석 - 배열과 문자열&quot;&gt;&lt;/a&gt;코딩인터뷰 완전 분석 - 배열과 문자열&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="CtCI" scheme="https://JeewhanR.github.io/categories/CtCI/"/>
    
    
      <category term="CtCI" scheme="https://JeewhanR.github.io/tags/CtCI/"/>
    
  </entry>
  
  <entry>
    <title>Big O Notation</title>
    <link href="https://JeewhanR.github.io/2018/03/24/2018-03-24-BigO/"/>
    <id>https://JeewhanR.github.io/2018/03/24/2018-03-24-BigO/</id>
    <published>2018-03-24T05:17:03.707Z</published>
    <updated>2018-04-30T18:05:04.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="코딩인터뷰-완전-분석-Big-O-Notation"><a href="#코딩인터뷰-완전-분석-Big-O-Notation" class="headerlink" title="코딩인터뷰 완전 분석 - Big O Notation"></a>코딩인터뷰 완전 분석 - Big O Notation</h1><h3 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h3><ul><li><p>점근적 실행 시간</p></li><li><p>그 중에서 Big O 표기법은 점근적 시간의 상한을 뜻한다</p><ul><li><p>계산 복잡도를 그래프로 나타내었을 때, 최악의 경우에도 알고리즘의 계산 복잡도에 비교했을 때 같거나 그보다 높은 곳에 위치할 그래프이기에 상한이라 칭한다</p></li><li><p><a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/" target="_blank" rel="noopener">점근적 표기법</a></p></li></ul></li><li><p>업계에선 Big O 표기법을 Big theta, 즉 수행 시간에 딱 맞추어 표기하려고 하는 경향이 있다</p></li><li><p>대부분의 알고리즘은 최악의 경우와 평균적인 경우가 같다</p></li></ul><h3 id="공간복잡도"><a href="#공간복잡도" class="headerlink" title="공간복잡도"></a>공간복잡도</h3><ul><li><p>시간복잡도와 평행선을 이룸</p></li><li><p>재귀 호출에 쓰이는 스택 공간도 포함됨</p><ul><li>꼬리 재귀 호출을 충족한다면 해당되지 않는다</li></ul></li></ul><h3 id="상수항은-무시하라-지배적이지-않은-항을-무시하라"><a href="#상수항은-무시하라-지배적이지-않은-항을-무시하라" class="headerlink" title="상수항은 무시하라, 지배적이지 않은 항을 무시하라"></a>상수항은 무시하라, 지배적이지 않은 항을 무시하라</h3><ul><li>Big O 표기법은 데이터의 증가에 따른 점근적 실행 시간의 변화증가율을 나타내기 위한 것이므로 무시한다</li></ul><h3 id="여러-부분으로-이루어진-알고리즘-덧셈-VS-곱셈"><a href="#여러-부분으로-이루어진-알고리즘-덧셈-VS-곱셈" class="headerlink" title="여러 부분으로 이루어진 알고리즘: 덧셈 VS 곱셈"></a>여러 부분으로 이루어진 알고리즘: 덧셈 VS 곱셈</h3><ul><li><p>A일을 모두 마치고 B일을 해야 한다면 A + B</p></li><li><p>A일을 할 때마다 B일을 해야 한다면 A * B</p></li></ul><h3 id="상환시간"><a href="#상환시간" class="headerlink" title="상환시간"></a>상환시간</h3><ul><li>ArrayList의 경우, 배열의 용량이 꽉 찼을 때, 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사한다, 이때 삽입 연산의 수행 시간은 기존의 모든 원소를 새 배열로 복사해야 하기에 O(N)이 소요된다, 그러나 배열에 가용 공간이 존재할 때 삽입 연산은 O(1)이 걸린다, 위 두 가지 경우를 포함한 전체 수행 시간을 따져볼 때 상환 시간이라는 개념을 이용한다, 최악의 경우는 가끔 발생하지만 해당 수행 시간을 나머지 경우에서 분할 상환한다는 개념이다, 위 케이스에서 배열의 크기가 2의 배수일 때 원소 삽입 연산에 O(N)이 소요된다, 이러한 N의 합은 X개의 원소를 삽입할 때 2X만큼 걸리므로 이를 분할 상환하면 삽입 한 번에 필요한 시간은 O(1)이다</li></ul><h3 id="log-N-수행-시간"><a href="#log-N-수행-시간" class="headerlink" title="log N 수행 시간"></a>log N 수행 시간</h3><ul><li><p>대표적인 케이스는 이진 탐색이다</p></li><li><p>탐색할 때마다 원소의 개수가 절반씩 줄어든다면, 수행 시간은 O(log N)일 가능성이 크다</p></li></ul><h3 id="재귀적으로-수행-시간-구하기"><a href="#재귀적으로-수행-시간-구하기" class="headerlink" title="재귀적으로 수행 시간 구하기"></a>재귀적으로 수행 시간 구하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f(n):</span><br><span class="line">    if n &lt;= 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return f(n - 1) + f(n - 1)</span><br></pre></td></tr></table></figure><ul><li><p>위 케이스의 수행 시간은 O(2^N)이다</p></li><li><p>트리의 깊이가 N이고, 각 노드는 두 개의 자식 노드를 가지고 있으므로 깊이가 깊어질 때마다 이전보다 두 배 더 많이 호출하게 되기 때문이다</p></li><li><p>다수의 호출로 이루어진 재귀 함수에서 수행 시간은 보통 O(분기^깊이)이다, 분기란 재귀 함수가 자신을 재호출하는 횟수를 뜻함</p></li><li><p>위 케이스의 공간복잡도는 O(N)이다</p></li></ul><h3 id="예제-및-연습-문제"><a href="#예제-및-연습-문제" class="headerlink" title="예제 및 연습 문제"></a>예제 및 연습 문제</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(array)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    product = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        sum += array[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        product *= array[i]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;sum&#125;</span>, <span class="subst">&#123;product&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">foo([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPairs</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;array[i]&#125;</span>, <span class="subst">&#123;array[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printPairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 총 수행 시간을 헤아리는 것 외에도, 위 코드가 무엇을 의미하는지 살펴보는 것을 통해 구할 수도 있다</span></span><br><span class="line"><span class="comment"># 위의 코드는 모든 쌍을 출력하는 코드이다, 그러므로 쌍의 총 개수인 N^2과 동일</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(array)):</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;array[i]&#125;</span>, <span class="subst">&#123;array[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 반복 횟수의 합</span></span><br><span class="line"><span class="comment"># 코드의 의미는 전체 쌍(사각형)의 절반</span></span><br><span class="line"><span class="comment"># 평균을 이용 =&gt; 바깥 루프는 N번, 안쪽 루프는 평균값으로 N/2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs2</span><span class="params">(array_a, array_b)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array_a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array_b)):</span><br><span class="line">            <span class="keyword">if</span> array_a[i] &lt; array_b[j]:</span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;array_a[i]&#125;</span>, <span class="subst">&#123;array_b[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) <span class="comment"># O(A*B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 두 배열 각각의 크기를 알 수 없으므로, 크기를 모두 고려해야 하므로 O(A*B)이다</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs3</span><span class="params">(array_a, array_b)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array_a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array_b)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;array_a[i], &#123;array_b[i]&#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs3([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) <span class="comment"># O(A*B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 100000은 상수항이므로 Big O에 영향을 미치지 못한다</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P74</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array) // <span class="number">2</span>):</span><br><span class="line">        other = len(array) - i - <span class="number">1</span></span><br><span class="line">        array[i], array[other] = array[other], array[i]</span><br><span class="line"></span><br><span class="line">reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 배열의 절반만 살펴본다고 해서 (반복횟수가 N의 절반이라고 해서) Big O에 영향을 끼치는 것은 아니다</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P &lt; N/2 일 때, O(N+P) 는 O(N)</span></span><br><span class="line"><span class="comment"># O(2N)은 O(N)</span></span><br><span class="line"><span class="comment"># O(N + logN)은 O(N)</span></span><br><span class="line"><span class="comment"># O(N+M)은 N과 M의 관계를 알 수 없다면 O(N+M)으로 표기해야 함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P75</span></span><br><span class="line"><span class="comment"># 여러 개의 문자열로 구성된 배열이 주어졌을 때, 각각의 문자열을 먼저 정렬하고</span></span><br><span class="line"><span class="comment"># 그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘의 수행시간은 어떠하겠는가?</span></span><br><span class="line"><span class="comment"># 각 문자열을 정렬 =&gt; O(NlogN)</span></span><br><span class="line"><span class="comment"># 모든 문자열을 정렬 =&gt; O(N*NlogN)</span></span><br><span class="line"><span class="comment"># 전체 문자열을 사전순으로 정렬 =&gt; O(NlogN) 추가</span></span><br><span class="line"><span class="comment"># 따라서 O(N^2logN + NlogN)이므로 O(N^2logN)이다 는 완전히 잘못된 분석!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 서로 다른 N을 혼용해서 쓰니까 위와 같은 오류를 범하게 된다</span></span><br><span class="line"><span class="comment"># 문자열의 길이를 나타낼 때와 배열의 길이를 나타낼 때를 구분하여 사용했어야 한다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 변수 N을 사용하지 않거나 N이 가리키는 것이 명백한 경우에만 사용하라</span></span><br><span class="line"><span class="comment"># 연상 가능한 이름을 사용해서 새로운 변수를 정의하라</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 가장 길이가 긴 문자열의 길이를 s라 하자</span></span><br><span class="line"><span class="comment"># 배열의 길이를 a라 하자</span></span><br><span class="line"><span class="comment"># 각 문자열을 정렬하는데 O(slogs)</span></span><br><span class="line"><span class="comment"># a개의 문자열이므로 O(a * slogs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 문자열을 사전순으로 정렬해야 함, 총 a개의 문자열이 있어서 O(aloga)가</span></span><br><span class="line"><span class="comment"># 필요하다고 생각할 수 있지만, 문자열을 비교하는 시간도 고려해야 한다</span></span><br><span class="line"><span class="comment"># 두 문자열을 비교하는데 O(s)가 소요되며, 비교를 O(aloga)번 해야 하므로</span></span><br><span class="line"><span class="comment"># 결론적으로 O(s*aloga)가 소요됨</span></span><br><span class="line"><span class="comment"># 위 두 부분을 합치면 전체 시간 복잡도는 O(a*s(logs + loga))가 된다</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P76</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNode</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> sumNode(node.left) + node.value + sum(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 균형 이진 탐색 트리에서 모든 노드의 값을 더하는 코드</span></span><br><span class="line"><span class="comment"># 이진 탐색 트리라는 이유로 log가 있을 것이라 착각해선 안 된다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 코드가 무엇을 의미하는가</span></span><br><span class="line"><span class="comment"># 트리의 모든 노드를 방문해서 합을 구하는 것이므로, 노드의 개수와 선형 관계</span></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 재귀호출 패턴 분석</span></span><br><span class="line"><span class="comment"># 재귀함수에 분기가 여러 개 존재할 때, 일반적으로 O(분기^깊이)가 된다</span></span><br><span class="line"><span class="comment"># 트리의 깊이는 N개에 대해 logN이다</span></span><br><span class="line"><span class="comment"># 분기가 2라면 2^logN이므로 O(N)이 된다</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P77</span></span><br><span class="line"><span class="comment"># N이 소수를 확인하려면 N의 제곱근까지만 확인해보면 된다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 어떤 수의 제곱근이란 그 수가 갖는 약수들 중에 자신을 제외하고 가장 큰 수. 라고 볼 수 있을 것 같아요.</span></span><br><span class="line"><span class="comment"># 소수라는게 1과 자기자신만을 약수로 가져야 하는데 또 다른 약수를 갖게 되면 안되는거니까</span></span><br><span class="line"><span class="comment"># 제곱근으로도 나누어 떨어지면 소수가 될 수 없는것이죠. 또한 어떤 수를 그 수의 제곱근 이상으로</span></span><br><span class="line"><span class="comment"># 나누게 되면 앞서 2부터 나누었던 결과가 반복되게 됩니다. 어떤 수를 2부터 제곱근까지의 수로</span></span><br><span class="line"><span class="comment"># 나눈다는 것을 그 수를 자신을 제외한 제수들로 나누었을 때 가질 수 있는 몫의 최소값(2)부터</span></span><br><span class="line"><span class="comment"># 최대값(제곱근)까지로 나눠 보는 것이라 생각하면 이해가 빠를 것 같아요.</span></span><br><span class="line"><span class="comment"># 제곱근 이상의 수로 나누게 되면 제곱근으로 나누었을 때보다 작은 몫을 결과로 반환하게 되서</span></span><br><span class="line"><span class="comment"># 제곱근 이하의 수로 나누었던 계산들을 반복하게 됩니다. 수 25에서 제곱근 5는 25가</span></span><br><span class="line"><span class="comment"># 가질 수 있는 몫의 최대값입니다. 그리고 그 이상의 수로 나누었을 때는 제곱근(5) 이하의 값들을</span></span><br><span class="line"><span class="comment"># 몫으로 반환하기 때문에 2부터 4까지 나누는 계산과 같게 되서 의미가 없는 거 같습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i ** <span class="number">2</span> &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 시간 복잡도는 O(√N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P78</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(s, prefix=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">        print(prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            rem = s[<span class="number">0</span>:i] + s[i+<span class="number">1</span>:]</span><br><span class="line">            permutation(rem, prefix + s[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N^2 * N!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 순열의 종류가 모두 출력되니, O(N!)</span></span><br><span class="line"><span class="comment"># 순열을 조합하기 위해서 N개의 글자만큼의 호출이 필요하므로 O(N)</span></span><br><span class="line"><span class="comment"># 매 for문마다 문자열을 재조립하거나, 출력하는 것과 같은 O(N) 연산 소요:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P79</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(2^N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 재귀 호출이 여러 번 발생하면 지수 시간 알고리즘일 가능성이 큼</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P80</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allFib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;fib(i)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(2^N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fib는 O(2^N)이 맞다, 그러나 전체 걸리는 시간은 O(N*2^N)이 아니다</span></span><br><span class="line"><span class="comment"># 그 이유는 각각의 호출시마다 N이 변화하기 때문이다</span></span><br><span class="line"><span class="comment"># 등비수열의 합공식에 따라 O(2^N+1)이 되므로 O(2^N)이다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># P81</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allFib</span><span class="params">(n)</span>:</span></span><br><span class="line">    memo = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;fib(i, memo)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n, memo)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> memo[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(memo) &gt; n <span class="keyword">or</span> n == <span class="number">1</span>: <span class="keyword">return</span> memo[n]</span><br><span class="line">    memo.append(fib(n<span class="number">-1</span>, memo) + fib(n<span class="number">-2</span>, memo))</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 상수 시간의 일을 N번 반복한다 (캐시값을 찾아서 더한 뒤 그 결과를 캐시 배열에 저장하고 반환)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P82</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powers_of_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prev = powers_of_2(n//<span class="number">2</span>)</span><br><span class="line">        curr = prev * <span class="number">2</span></span><br><span class="line">        print(curr)</span><br><span class="line">        <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(logN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1이 될 때까지 절반씩 나누므로 log</span></span><br><span class="line"><span class="comment"># 해당 코드의 목적을 생각해보면, 1부터 n사이의 모든 2의 승수를 계산하고 출력하므로</span></span><br><span class="line"><span class="comment"># 함수의 호출 횟수는 승수의 개수와 동일하다</span></span><br><span class="line"><span class="comment"># n이 커질수록 수행 시간이 어떻게 바뀌는가? n의 크기가 두 배가 될 때 호출 횟수가 한 번 증가한다</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># P83</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b):</span><br><span class="line">        sum += a</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P84</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> b == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> a * power(a, b - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    div = a / b</span><br><span class="line">    <span class="keyword">return</span> a - div * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sum = b</span><br><span class="line">    <span class="keyword">while</span> sum &lt;= a:</span><br><span class="line">        sum += b</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(a/b)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sqrt_helper(n, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt_helper</span><span class="params">(n, mi, ma)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ma &lt; mi: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    guess = (mi + ma) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> guess * guess == n: <span class="keyword">return</span> guess</span><br><span class="line">    <span class="keyword">elif</span> guess * guess &lt; n: <span class="keyword">return</span> sqrt_helper(n, guess + <span class="number">1</span>, ma)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> sqrt_helper(n, mi, guess - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(logN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P85</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(n)</span>:</span></span><br><span class="line">    guess = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> guess * guess &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> guess * guess == n:</span><br><span class="line">            <span class="keyword">return</span> guess</span><br><span class="line">        guess += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># O(√N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 이진 탐색 트리가 균형 잡혀있지 않을 때, 원소를 찾는데 걸리는 최악의 경우</span></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 이진 트리가 이진 탐색 트리가 아닐 때 시간 복잡도</span></span><br><span class="line"><span class="comment"># O(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyArray</span><span class="params">(array)</span>:</span></span><br><span class="line">    copy = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array:</span><br><span class="line">        copy = appendToNew(copy, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendToNew</span><span class="params">(array, value)</span>:</span></span><br><span class="line">    bigger = [<span class="number">0</span>] * len(array)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        bigger[i] = array[i]</span><br><span class="line"></span><br><span class="line">    bigger.append(value)</span><br><span class="line">    <span class="keyword">return</span> bigger</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N^2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># P86</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumDigits</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        sum += n % <span class="number">10</span></span><br><span class="line">        n //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(logN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_11.java</span></span><br><span class="line">numChars = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSortedStrings</span><span class="params">(remaining, prefix=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> remaining == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> isInOrder(prefix):</span><br><span class="line">            print(prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numChars):</span><br><span class="line">            c = ithLetter(i)</span><br><span class="line">            printSortedStrings(remaing - <span class="number">1</span>, prefix + c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isInOrder</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">        prev = ithLetter(s[i<span class="number">-1</span>])</span><br><span class="line">        curr = ithLetter(s[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prev &gt; curr:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ithLetter</span><span class="params">(i)</span>:</span></span><br><span class="line">    return ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_12.java</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    mergesort(b)</span><br><span class="line">    intersect = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> binarySearch(b, x) &gt;= <span class="number">0</span>:</span><br><span class="line">            intersect += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> intersect</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;코딩인터뷰-완전-분석-Big-O-Notation&quot;&gt;&lt;a href=&quot;#코딩인터뷰-완전-분석-Big-O-Notation&quot; class=&quot;headerlink&quot; title=&quot;코딩인터뷰 완전 분석 - Big O Notation&quot;&gt;&lt;/a&gt;코딩인터뷰 
      
    
    </summary>
    
      <category term="CtCI" scheme="https://JeewhanR.github.io/categories/CtCI/"/>
    
    
      <category term="CtCI" scheme="https://JeewhanR.github.io/tags/CtCI/"/>
    
  </entry>
  
  <entry>
    <title>이벤트 델리게이션</title>
    <link href="https://JeewhanR.github.io/2018/03/13/2017-10-08-Event-Delegation/"/>
    <id>https://JeewhanR.github.io/2018/03/13/2017-10-08-Event-Delegation/</id>
    <published>2018-03-12T15:37:08.412Z</published>
    <updated>2018-04-30T18:03:33.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이벤트-델리게이션"><a href="#이벤트-델리게이션" class="headerlink" title="이벤트 델리게이션"></a>이벤트 델리게이션</h1><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><ul><li>Javascript Event<ul><li>addEventListener<ul><li>Event Delegation</li></ul></li><li>Event Bubbling, Event Capturing<ul><li>Event Object</li></ul></li><li>Event Target</li></ul></li></ul><hr><h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>SPA 이전 웹사이트들에서 자바스크립트의 중요한 역할은 웹사이트의 동작을 구현하는 것입니다. 여기서 말하는 동작은 애니메이션이 아닌, 동적인 상호작용을 뜻합니다. (애니메이션은 CSS3의 역할이라고 생각합니다.)</p><p>위와 같은 동적인 상호작용을 <code>Event</code>라고 지칭합니다. 사용자의 이벤트 요청을 받아들이기 위해서는 사용자의 이벤트 요청을 받아들이기 위한 장치를 마련해두어야 합니다.</p><p>이를 위한 가장 일반적인 방법이 <code>addEventListener()</code>입니다. <code>addEventListener()</code>의 대상이 될 수 있는 <code>EventTarget</code>은 <code>Element</code>, <code>Document</code>, <code>Window</code>와 같은 이벤트를 지원하는 객체입니다. 일반적으로는 <code>document.querySelector()</code>를 통해 특정 <code>Element</code>를 지칭하여 <code>addEventListener()</code>를 호출합니다.</p><p>IE9부터 사용 가능한 <code>addEventListener()</code>는 다음과 같은 인자를 갖고 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener MDN</a></p><p><code>type</code>, <code>listener</code>, <code>options || useCapture</code>, <code>wantsUntrusted</code></p><ul><li><code>type</code></li></ul><p><code>EventTarget</code>에 어떤 <code>Event</code>가 일어났을 때, <code>listener parameter</code>를 호출할지 결정하는 문자열입니다. 어떤 종류가 있는지는 다음 페이지에서 확인할 수 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">Event reference MDN</a> 일반적으로 많이 사용하는 것은 <code>click</code>, <code>load</code> 등입니다.</p><ul><li><code>listener()</code></li></ul><p><code>type</code>에서 정의한 <code>event</code>가 발생했을 때 호출될 객체입니다. 일반적으로 자바스크립트 함수로 합니다. 이 함수를 웹 브라우저가 호출하면서 인수로 <code>Event</code> 객체를 넘겨줍니다. 이 인자를 일반적으로 <code>e</code> 또는 <code>event</code>로 정의합니다. 가장 많이 사용하는 것은 <code>Event</code> 의 target property입니다.</p><p><code>listener</code>가 <code>return false</code>를 반환할 경우, <code>preventDefault()</code>를 한 것과 동일한 효과를 보입니다. <code>preventDefault()</code>는 해당 <code>Node</code>의 기본 동작을 막는 함수입니다. 예를 들어 <code>&lt;a&gt;</code>에서 <code>EventListener</code>가 호출되었을 때는 <code>listener</code>와 더불어 <code>&lt;a&gt;</code>의 본래 역할인 URL 연결도 수행하는데, 이를 막을 수 있습니다.</p><ul><li><code>options</code> <code>||</code>  <code>useCapture</code></li></ul><p>인수가 <code>object</code>이면 options를, <code>boolean</code>을 넘겨주면 useCapture로 인식합니다. <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#eventlisteneroptions" target="_blank" rel="noopener">WICG Link</a></p><ul><li><code>useCaputre</code>일 때 (default <code>false</code>)</li></ul><p>이 인자는 <code>Capture Phase</code>일 때의 <code>Event</code> 수신 여부를 결정합니다.</p><p>false일 경우 이벤트가 발생한 <code>node</code>로부터 <code>window</code>까지 <code>Event</code>가 전파되는 시점에 <code>Event</code>를 받게 됩니다. <code>Event Bubbling</code>이라고 합니다.</p><p>true일 경우 <code>Window</code>부터 이벤트가 발생한 <code>node</code>까지 <code>Event</code>가 전파되는 시점에 <code>Event</code>를 받게 됩니다. 이것을 <code>Event Capturing</code>이라고 합니다.</p><ul><li><code>options</code>일 때</li></ul><p><code>capture</code>: <code>Capturing</code> 유무</p><p><code>once</code>: <code>true</code>를 넘겨주면, <code>EventListener</code>를 일회성으로 만들 수 있습니다.</p><p><code>passive</code>: <code>listener</code>에서의 <code>preventDefault</code> 호출 허용 여부를 결정합니다.</p><p><code>mozSystemGroup</code></p><p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt="img"></p><p><a href="https://codepen.io/jeewhan/pen/XeaXGJ" target="_blank" rel="noopener">Codepen 예제</a></p><hr><p>그렇다면 왜 이벤트 위임을 해야 하는가?</p><p>하나의 부모 <code>Node</code> 밑에 있는 자식 <code>Node</code>들이 있다고 가정해보겠습니다. 해당 자식 <code>Node</code>들은 모두 동일한 <code>Event</code>를 발생시키길 기대합니다.</p><p>이벤트 위임을 하지 않을 경우, 자식 <code>Node</code>마다 <code>Event Listener</code>를 추가해주어야 하는 것은 물론, 이후에 자식 <code>Node</code>가 늘어날 때마다 <code>Event Listener</code>도 추가해주어야 합니다. 이렇게 하게 되면 성능도 안 좋겠지만, 프로그래머 입장에서도 매우 번거롭습니다.</p><p>그래서 자식 <code>Node</code>마다 <code>Event Listener</code>를 부여하지 않고, 그들의 부모 <code>Node</code>에게만 <code>Event Listener</code>를 부여하고, 자식에서 발생하는 <code>Event</code>를 받아 처리하도록 하는 것을  이벤트 위임이라고 합니다. 그러면 자식 <code>Node</code>가 늘어날 때마다 <code>Event Listener</code>를 늘릴 필요없이 부모의 <code>Event Listener</code>의 <code>listener</code>에 분기 처리만 해주면 됩니다.</p><p>이벤트 위임에는 당연히 이벤트 전파가 전제되어 있습니다. 따라서 프로그래머가 의도한 방향대로 동작하게 하려면 이벤트 전파를 제어할 수 있어야 합니다. 그러기 위해서 <code>stopPropagation()</code> <code>stopImmediatePropagation()</code> 를 사용할 수 있습니다.</p><ul><li><code>stopPropagation()</code><br><code>Event</code>가 <code>Parent Node</code>로 전파되지 않도록 합니다. 이 함수의 적용 시점은 <code>Bubbling Phase</code>이기에, <code>Capture</code>와는 무관합니다.</li></ul><ul><li><code>stopImmediatePropagation()</code><br><code>stopPropagation()</code>와 더불어 <code>Sibling Node</code>에게도 <code>Event</code>가 전달되지 않도록 합니다.</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://programmingsummaries.tistory.com/313" target="_blank" rel="noopener">Javascript에서 이벤트 전파를 중단하는 네 가지 방법</a></li><li><a href="https://github.com/nhnent/fe.javascript/wiki/August-22-August-26,-2016" target="_blank" rel="noopener">왜 이벤트 위임(delegation)을 해야 하는가?</a></li><li><a href="http://poiemaweb.com/js-event" target="_blank" rel="noopener">PoiemaWeb Javascript Event</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이벤트-델리게이션&quot;&gt;&lt;a href=&quot;#이벤트-델리게이션&quot; class=&quot;headerlink&quot; title=&quot;이벤트 델리게이션&quot;&gt;&lt;/a&gt;이벤트 델리게이션&lt;/h1&gt;&lt;h3 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;he
      
    
    </summary>
    
      <category term="JS" scheme="https://JeewhanR.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://JeewhanR.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Codility ~7</title>
    <link href="https://JeewhanR.github.io/2018/03/12/2018-04-22-Codility7/"/>
    <id>https://JeewhanR.github.io/2018/03/12/2018-04-22-Codility7/</id>
    <published>2018-03-12T07:42:48.062Z</published>
    <updated>2018-04-30T18:06:00.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실용적인-알고리즘-3-Codility-7"><a href="#실용적인-알고리즘-3-Codility-7" class="headerlink" title="실용적인 알고리즘 (3) - Codility ~7"></a>실용적인 알고리즘 (3) - Codility ~7</h1><blockquote><p>문제 앞에 * 이 붙어있으면 어려웠던 문제이다</p></blockquote><p>이 글은 해답은 보고 싶지 않고, 문제 풀이는 막혀서 힌트만 받고 싶은 (아래 문제들을 풀 때의 나와 같은) 사람들에게 도움이 되는 것을 목표로 작성하였다</p><h2 id="Prefix-Sums"><a href="#Prefix-Sums" class="headerlink" title="Prefix Sums"></a>Prefix Sums</h2><h3 id="CountDiv"><a href="#CountDiv" class="headerlink" title="CountDiv"></a><a href="https://app.codility.com/programmers/lessons/5-prefix_sums/count_div/" target="_blank" rel="noopener">CountDiv</a></h3><p>문제에서 요구하는 시간복잡도가 O(1)이므로 loop 없이 식을 거치면 바로 결과를 반환할 수 있어야 한다</p><p>실제 문제 난이도에 비해서 한참 헤매었던 문제인데, <strong>나눗셈</strong>의 의미를 생각해보고 <strong>케이스 분류</strong>만 잘 하면 쉬운 문제이다</p><p><a href="https://app.codility.com/demo/results/trainingFJEKVX-9DK/" target="_blank" rel="noopener">내 코드</a></p><hr><h3 id="PassingCars"><a href="#PassingCars" class="headerlink" title="PassingCars"></a><a href="https://app.codility.com/programmers/lessons/5-prefix_sums/passing_cars/" target="_blank" rel="noopener">PassingCars</a></h3><p>문제에서 요구하는 시간복잡도가 O(N)이므로 한 번의 loop만으로 문제를 해결해야 한다</p><p>따라서 <strong>stack</strong>을 활용해야 했다</p><p><a href="https://app.codility.com/demo/results/trainingTFAZYA-4ZF/" target="_blank" rel="noopener">내 코드</a></p><hr><h3 id="MinAvgTwoSlice"><a href="#MinAvgTwoSlice" class="headerlink" title="* MinAvgTwoSlice"></a>* <a href="https://app.codility.com/programmers/lessons/5-prefix_sums/min_avg_two_slice/" target="_blank" rel="noopener">MinAvgTwoSlice</a></h3><p>문제에서 요구하는 시간복잡도가 O(N)이므로 <strong>최소값을 기록 및 대조</strong>하면서 loop를 순회해야 한다</p><p>이 문제에서 원하는 <strong>부분집합은 2개 또는 3개로 모두 설명될 수 있다</strong>는 점도 중요했다</p><p><a href="https://app.codility.com/demo/results/trainingSZNUV4-SX8/" target="_blank" rel="noopener">내 코드</a></p><hr><h3 id="GenomicRangeQuery"><a href="#GenomicRangeQuery" class="headerlink" title="* GenomicRangeQuery"></a>* <a href="https://app.codility.com/programmers/lessons/5-prefix_sums/genomic_range_query/" target="_blank" rel="noopener">GenomicRangeQuery</a></h3><p>문제에서 요구하는 시간복잡도가 O(N+M)이므로, <strong>중복되지 않는 두 번의 loop</strong>를 사용해야 한다</p><p>Input의 구간이 어떻게 올지 모르는 상태에서 해당 구간의 최소값을 구할 수 있어야 하므로, 한 번의 loop를 통해 기록을 해두어야 한다</p><p>또한 나머지 한 번의 루프를 통해 각각의 기록들을 비교하여 답을 내야 한다다</p><p><a href="https://app.codility.com/demo/results/trainingXD537B-EQJ/" target="_blank" rel="noopener">내 코드</a></p><hr><h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a><a href="https://app.codility.com/programmers/lessons/6-sorting/triangle/" target="_blank" rel="noopener">Triangle</a></h3><p><a href="https://app.codility.com/demo/results/trainingDJRKKY-XQP/" target="_blank" rel="noopener">내 코드</a></p><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a><a href="https://app.codility.com/programmers/lessons/6-sorting/distinct/" target="_blank" rel="noopener">Distinct</a></h3><p><a href="https://app.codility.com/demo/results/trainingNEVMH3-VN6/" target="_blank" rel="noopener">내 코드</a></p><p>설명할 필요가 없는 문제들이다</p><hr><h3 id="MaxProductOfThree"><a href="#MaxProductOfThree" class="headerlink" title="MaxProductOfThree"></a><a href="https://app.codility.com/programmers/lessons/6-sorting/max_product_of_three/" target="_blank" rel="noopener">MaxProductOfThree</a></h3><p>Input되는 배열의 각 요소별 조건이 무엇인지만 유념하면 되는 문제</p><p><a href="https://app.codility.com/demo/results/training4QFT9V-QVH/" target="_blank" rel="noopener">내 코드</a></p><hr><h3 id="NumberOfDiscIntersections"><a href="#NumberOfDiscIntersections" class="headerlink" title="* NumberOfDiscIntersections"></a>* <a href="https://app.codility.com/programmers/lessons/6-sorting/number_of_disc_intersections/" target="_blank" rel="noopener">NumberOfDiscIntersections</a></h3><p>우선 접점의 정의를 정확히 찾아보고 시작해야 한다</p><p><strong>stack</strong>을 활용하면 풀 수 있다, 또한 X좌표와 시작지점인지 여부를 동시에 표시해야 하므로 배열을 활용하면 좋다</p><p>인터넷에 범위를 점점 줄여나가는 이중 loop로 푸는 해답이 많은데,<br>문제에서 요구하는 시간복잡도가 O(N*log(N))이므로<br>stack을 활용하는 방향이 더 좋은 것 같다고 생각한다</p><p><a href="https://app.codility.com/demo/results/trainingCQ83SA-5QJ/" target="_blank" rel="noopener">내 코드</a></p><hr><h2 id="Stacks-and-Queues"><a href="#Stacks-and-Queues" class="headerlink" title="Stacks and Queues"></a>Stacks and Queues</h2><h3 id="StoneWall"><a href="#StoneWall" class="headerlink" title="StoneWall"></a><a href="https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/" target="_blank" rel="noopener">StoneWall</a></h3><p><a href="https://app.codility.com/demo/results/training3C9PXC-NGU/" target="_blank" rel="noopener">내 코드</a></p><h3 id="Brackets"><a href="#Brackets" class="headerlink" title="Brackets"></a><a href="https://app.codility.com/programmers/lessons/7-stacks_and_queues/brackets/" target="_blank" rel="noopener">Brackets</a></h3><p><a href="https://app.codility.com/demo/results/training7WVQ6J-PCQ/" target="_blank" rel="noopener">내 코드</a></p><h3 id="Fish"><a href="#Fish" class="headerlink" title="Fish"></a><a href="https://app.codility.com/programmers/lessons/7-stacks_and_queues/fish/" target="_blank" rel="noopener">Fish</a></h3><p><a href="https://app.codility.com/demo/results/trainingT4DR4Q-YGN/" target="_blank" rel="noopener">내 코드</a></p><h3 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a><a href="https://app.codility.com/programmers/lessons/7-stacks_and_queues/nesting/" target="_blank" rel="noopener">Nesting</a></h3><p><a href="https://app.codility.com/demo/results/training4W8H2J-F3F/" target="_blank" rel="noopener">내 코드</a></p><p>전형적인 stack 활용 문제들이다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;실용적인-알고리즘-3-Codility-7&quot;&gt;&lt;a href=&quot;#실용적인-알고리즘-3-Codility-7&quot; class=&quot;headerlink&quot; title=&quot;실용적인 알고리즘 (3) - Codility ~7&quot;&gt;&lt;/a&gt;실용적인 알고리즘 (3) -
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Codility ~4</title>
    <link href="https://JeewhanR.github.io/2018/03/12/2018-03-13-Codility4/"/>
    <id>https://JeewhanR.github.io/2018/03/12/2018-03-13-Codility4/</id>
    <published>2018-03-12T07:42:48.062Z</published>
    <updated>2018-04-30T18:05:45.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실용적인-알고리즘-2-Codility-4"><a href="#실용적인-알고리즘-2-Codility-4" class="headerlink" title="실용적인 알고리즘 (2) - Codility ~4"></a>실용적인 알고리즘 (2) - Codility ~4</h1><blockquote><p>문제 앞에 * 이 붙어있으면 어려웠던 문제이다</p></blockquote><h2 id="Iterations"><a href="#Iterations" class="headerlink" title="Iterations"></a>Iterations</h2><h3 id="BinaryGap"><a href="#BinaryGap" class="headerlink" title="BinaryGap"></a><a href="https://app.codility.com/programmers/lessons/1-iterations/binary_gap/" target="_blank" rel="noopener">BinaryGap</a></h3><p>문제에서 요구하는 시간복잡도 O(log(N))</p><p>=&gt; 이진탐색과 같이, 거듭 2로 나누어서 정답을 구하는 과정이겠구나 라고 예상해볼 수 있다.</p><p>2진수 구하는 방법을 기본적으로 익히고 있어야 할 것 같다.</p><p>관련해서 떠오른 글</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Frank Hyunsok Oh</span><br><span class="line"></span><br><span class="line">학습 효율을 위해서는 기본적인 언어와 라이브러리 기능 숙지 외에 대충 3가지 층위의 연습이 필요한 것 같습니다.</span><br><span class="line"></span><br><span class="line">- 기본적으로 해당 언어에서 자주 발생하는 간단한 과업을 처리할 때 사용하는 숙어를 숙지하는 연습.</span><br><span class="line"></span><br><span class="line">예를 들어 C에서 정수 스왑시 a ^= b; b ^= a; a ^= b; 라던지 1중 또는 2중, 3중 for루프를 돌려가면서 삼각형을 그린다던지,</span><br><span class="line"></span><br><span class="line">실수를 정수화하는 여러가지 방법이라던지.. 이런 자잘한 숙어를 익혀두고 연습할 수 있는 교재나 도구가 필요한 것 같습니다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 여러 숙어를 엮어서 함수(또는 메소드와 객체)를 만들고 이를 엮어서 한가지 API를 제공하는 독립된 단위(모듈이라고 불러도 좋고)을 만드는 연습</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 여러 모듈을 조합해 원하는 목표를 달성하는 애플리케이션을 만드는 연습.</span><br><span class="line"></span><br><span class="line">게임도 좋고 개밥 먹기를 위한 간단한 유틸리티도 좋고, 책에서 본 예제를 자신의 방식으로 만들어 보는 것도 좋죠.</span><br><span class="line"></span><br><span class="line">요구사항을 추출하고 거기서 프로그램을 설계하고 코딩하는 과정과 그 과정에서 프로젝트 진행과 품질을 관리하고 디버깅하는 경험을 쌓아야 합니다.</span><br></pre></td></tr></table></figure><hr><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="CyclicRotation"><a href="#CyclicRotation" class="headerlink" title="CyclicRotation"></a><a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/" target="_blank" rel="noopener">CyclicRotation</a></h3><p>배열에 대한 입출력 메소드를 알고 있는가?</p><p>unshift : 배열의 맨 앞에 데이터를 추가하고 길이를 반환</p><p>shift : 배열의 맨 앞 데이터를 제거하고 제거된 값, 빈 배열이면 undefined를 반환</p><p>push : 배열의 맨 끝에 데이터를 추가하고, 길이를 반환</p><p>pop : 배열의 맨 끝 데이터를 제거하고, 제거된 값, 빈 배열이면 undefined를 반환</p><h3 id="OddOccurrencesInArray"><a href="#OddOccurrencesInArray" class="headerlink" title="OddOccurrencesInArray"></a><a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/" target="_blank" rel="noopener">OddOccurrencesInArray</a></h3><p>문제에서 요구하는 시간복잡도 O(N)</p><p>M * N일 수는 있지만 결국은 순회할 때 그 안에서 for문을 하는 등의 작업은 불가능</p><p>즉 순회 과정에서 기존에 나왔던 숫자인지 비교하기 위한 로직을 O(1)로 구현할 수 있어야 함</p><p>그러기 위해선 그 전에 나왔던 숫자에 대해 저장해놓는 과정이 필요하니, 이것을 Dictionary 형태를 활용해서 구현</p><p>(배열 형태로 만들게 되면 배열에서 해당 값이 저장되어있는 위치를 찾기 위해 순회하는 과정이 필요하게 되므로 O(1)이 성립하지 않게 됨)</p><h3 id="TapeEquilibrium"><a href="#TapeEquilibrium" class="headerlink" title="TapeEquilibrium"></a><a href="https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/" target="_blank" rel="noopener">TapeEquilibrium</a></h3><p>문제에서 요구하는 시간복잡도 O(N)</p><p>2-2가 그랬듯이, left와 right를 순회시마다 구할 수는 없음</p><p>따라서 순회시마다 변화하는 값을 통해 비교할 수 있어야 함</p><p>여기서는 정방향으로 순회시에 순회 때마다 우측에 있던 값이 좌측으로 옮겨가는 구조이므로</p><p>순회시마다 값을 좌측에 더하고, 우측에서 빼고 문제에서 차의 절대값의 크기를 구해야 함</p><p>이때도 가장 작은 값을 찾기 위해선 기존에 저장해놓은 차이값과 비교해서 더 작으면 덮어쓰고 아니면 Pass하는 방식으로 진행 필요</p><hr><h2 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h2><h3 id="PermMissingElem"><a href="#PermMissingElem" class="headerlink" title="PermMissingElem"></a><a href="https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/" target="_blank" rel="noopener">PermMissingElem</a></h3><p>문제에서 요구하는 시간복잡도 O(N)</p><p>원래 나올 수 있는 숫자를 모두 만들어놓고 없애가면서 남아있는 숫자를 보여주고,</p><p>제한사항에 있는 예외사항([]) 등을 처리하는 방식도 가능하지만,</p><p>문제의 데이터가 모두 숫자이고, 누락된 하나의 값을 찾는다는 점에서 차를 통해서 구하는 것도 가능합니다</p><hr><h2 id="Counting-Elements"><a href="#Counting-Elements" class="headerlink" title="Counting Elements"></a>Counting Elements</h2><h3 id="FrogRiverOne"><a href="#FrogRiverOne" class="headerlink" title="FrogRiverOne"></a><a href="https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/" target="_blank" rel="noopener">FrogRiverOne</a></h3><p>문제에서 요구하는 시간복잡도 O(N)</p><p>X값을 통해 채워져야 할 모든 숫자 값을 미리 배열에 담아놓고, 숫자가 나올 때마다 count를 해서, X값과 같은 값이 나오면 리턴해주고 끝까지 나오지 않는다면 -1</p><h3 id="MissingInteger-PermCheck"><a href="#MissingInteger-PermCheck" class="headerlink" title="MissingInteger / PermCheck"></a><a href="https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/" target="_blank" rel="noopener">MissingInteger</a> / <a href="https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/" target="_blank" rel="noopener">PermCheck</a></h3><p>앞선 문제들과 동일한 패턴으로 풀 수 있는 문제이다.</p><h3 id="MaxCounters"><a href="#MaxCounters" class="headerlink" title="* MaxCounters"></a>* <a href="https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/" target="_blank" rel="noopener">MaxCounters</a></h3><p>앞 문제들과 비슷하지만, 조금 더 복잡한 문제이다.</p><p>숫자들에 대해서 재평가가 필요할 때까지 평가를 미뤄두고, 재평가가 되어야 할 때 미리 저장해놓은 값과 비교하여 평가해야 한다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;실용적인-알고리즘-2-Codility-4&quot;&gt;&lt;a href=&quot;#실용적인-알고리즘-2-Codility-4&quot; class=&quot;headerlink&quot; title=&quot;실용적인 알고리즘 (2) - Codility ~4&quot;&gt;&lt;/a&gt;실용적인 알고리즘 (2) -
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://JeewhanR.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>글쓰기 시작</title>
    <link href="https://JeewhanR.github.io/2018/03/07/2018-02-12-Start/"/>
    <id>https://JeewhanR.github.io/2018/03/07/2018-02-12-Start/</id>
    <published>2018-03-07T03:19:42.268Z</published>
    <updated>2018-04-30T18:02:34.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="글쓰기-시작"><a href="#글쓰기-시작" class="headerlink" title="글쓰기 시작"></a>글쓰기 시작</h3><p>글쓰기는 내게 가장 어려운 일 중 하나였다.</p><p>스스로 가지고 있는 글쓰기 실력에 비해 눈높이가 높은 까닭일 것이다.</p><p>그래서 항상 미루고 또 미뤄왔고, 그렇기 때문에 더더욱 어렵게 느껴졌다.</p><p>그러던 내가 용기를 내게 된 것은 매일 한 문제 이상 알고리즘을 푼다는 습관이 성공적으로 정착되고 있는 ‘작은 성공’을 보면서 글쓰기도 할 수 있다고 생각하게 된 덕분이었다.</p><p>물론 이 습관도 그냥 생긴 것은 아니었으며, 매일 스스로 약속한 것을 지키고 인증하는 모임에 참여하고 있는 점이 가장 컸다.</p><p>해서, 성윤님이 모집하신 모임에 참여하면 글쓰기도 가능할 것이다 라고 생각하였고, 드디어 시작을 하게 되었다.</p><p>최근에 읽은 아티클 중에 관련하여 글쓰기와 관련하여 가장 인상적이었던 것은 <a href="http://ppss.kr/archives/151423" target="_blank" rel="noopener">글쓰기가 안 되는 분들을 위한 4단계 작문법</a> 이었다.</p><p>위 내용을 보고 여태까지 글쓰기가 힘들었던 것은 정신병자 단계를 거치지 않고 판사와 같은 마음으로 바라보고 있었기 때문이라는 것을 느꼈다.</p><p>그러다보면 이터레이션 주기가 길어지고, 따라서 성공할 수가 없었던 것이다. <img src="https://image.slidesharecdn.com/datamoney-150827021417-lva1-app6892/95/-21-1024.jpg?cb=1440662401" alt="image"></p><p>앞으로 최대한 편안한 마음으로 좋은 글이 아닌, 그저 지각하지 않고 제때 제출하는 것만을 목표로 써보려고 한다.</p><p>그 과정에서 다른 분들과 많이 교류하며 글쓰기 외에도 많은 것들을 얻어갈 수 있기를 바란다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;글쓰기-시작&quot;&gt;&lt;a href=&quot;#글쓰기-시작&quot; class=&quot;headerlink&quot; title=&quot;글쓰기 시작&quot;&gt;&lt;/a&gt;글쓰기 시작&lt;/h3&gt;&lt;p&gt;글쓰기는 내게 가장 어려운 일 중 하나였다.&lt;/p&gt;
&lt;p&gt;스스로 가지고 있는 글쓰기 실력에 비해 
      
    
    </summary>
    
      <category term="Essay" scheme="https://JeewhanR.github.io/categories/Essay/"/>
    
    
      <category term="Essay" scheme="https://JeewhanR.github.io/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>반대로 하는 법</title>
    <link href="https://JeewhanR.github.io/2018/03/07/2017-04-12-Contrary/"/>
    <id>https://JeewhanR.github.io/2018/03/07/2017-04-12-Contrary/</id>
    <published>2018-03-07T03:19:42.264Z</published>
    <updated>2018-04-30T18:02:26.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="반대로-하는-법"><a href="#반대로-하는-법" class="headerlink" title="반대로 하는 법"></a>반대로 하는 법</h3><p>오늘 체형교정 관련한 세션에 다녀왔다.</p><p>강사님의 입담도 매우 좋으셨고, 도움이 되는 여러 가지 얘기들을 많이 들었다.</p><p>그 내용들을 딱 하나로 압축해본다면 <code>평소의 반대로 스트레칭</code>이었다.</p><p>평소에 앞으로 쏠려있는 상체는 뒤로, 우뚝 솟아있는 어깨는 아래로, 앞으로 몰려있는 어깨는 뒤로-</p><p>그러다보면 몸의 균형이 잡히고, 몸을 바르게 쓰게 될 수 있을 것이라 말했다.</p><p>몸만 그러할까? 아니다 그렇지 않다.</p><p>무엇이든 다양한 요구사항과 제한된 환경을 극복하려다보면 모든 것을 만족시킬 수 있는 것은 없는 법이다.</p><p>어느 하나에 치우쳐지면 반드시 트레이드 오프된 다른 하나가 부메랑처럼 돌아온다.</p><p>그러므로 우선순위에 따른 나름의 균형을 맞춰줘야 한다.</p><p>위와 같은 내용을 모르지 않는데, 쉽지 않은 것은 늘 알면서도 평소와 같이 하기 때문은 아닐까.</p><p>그렇다면 관성을 벗어나려면 어떻게 해야 할까? 두 가지가 필요할 것 같다. <code>관찰</code>과 <code>피드백</code></p><p>루틴대로 그냥 쉽게 처리하지 않고, 관찰하려면 의식적인 자각과 그 지루함을 견딜 수 있는 여유가 필요하다.</p><p>의식적인 자각은 의지가 아닌 환경에 따른 장치가 있으면 조금 더 수월하지 않을까?</p><p>그러기 위해서 흔히들 목표를 손으로 적어서 눈에 보이는 곳에 두라고 하는 듯 하다.<br>(개인적인 생각으로는 한국은 환경에 비해 의지와 노오오오력을 너무 강조한다고 생각한다.<br>개인의 실패를 개인에게 떠넘기기 위해서일까.)</p><p>조급함을 견딜 수 있는 여유는 <code>버리는 것</code>에서 오지 않을까?</p><p>사람은 결국 한 번에 하나 밖에 못한다고 생각한다.</p><p>그렇기 때문에 지금 당장 붙잡고 할 수 있는 것 또는 해야 하는 것 외에는 마음 속에서 잠시 감춰둘 수 있는 요령이 필요한 것 같다.</p><p>문제해결이란 결국 한 번에 하나씩 집중적으로 풀어가야 하는 법이니까.</p><p>피드백을 잘 받으려면 어떻게 해야 할까? 이 역시 두 가지가 필요할 것 같다. <code>질문</code>과 <code>변화</code></p><p>질문을 어떻게 해야 하는지 인지한지 얼마 되지 않았다.</p><p>내가 알고 있는 가장 좋은 질문 방법은 질문을 받는 사람이 한 입에 쏙 먹기 좋게끔 아주 간결하게만 던지는 것이다.</p><p>조금만 질문이 길어져도 금방 집중력을 잃고 원래 들을 수 있었던 말조차 듣지 못 하게 될 수 있으니,<br>디테일한 상황을 전달하고 싶은 욕심을 잠시 내려놓고 아주 핵심적인 것만 물어볼 수 있어야 한다.</p><p>또한 피드백이 일회성에 끝나지 않도록 하려면, 그 전 질문에 대한 반응을 잘 반영해야 한다, 그러기 위해서라도 앞의 질문은 많이 할 수가 없다.<br>원래 말을 들은 사람은 기억하지 못해도, 해준 사람은 다 기억하는 법이다.</p><p>위와 같이 하면 조금은 그 전과 반대로 할 수 있지 않을까…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;반대로-하는-법&quot;&gt;&lt;a href=&quot;#반대로-하는-법&quot; class=&quot;headerlink&quot; title=&quot;반대로 하는 법&quot;&gt;&lt;/a&gt;반대로 하는 법&lt;/h3&gt;&lt;p&gt;오늘 체형교정 관련한 세션에 다녀왔다.&lt;/p&gt;
&lt;p&gt;강사님의 입담도 매우 좋으셨고,
      
    
    </summary>
    
      <category term="Essay" scheme="https://JeewhanR.github.io/categories/Essay/"/>
    
    
      <category term="Essay" scheme="https://JeewhanR.github.io/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>React 입문</title>
    <link href="https://JeewhanR.github.io/2018/03/07/2018-03-07-React-Intro/"/>
    <id>https://JeewhanR.github.io/2018/03/07/2018-03-07-React-Intro/</id>
    <published>2018-03-06T16:44:12.613Z</published>
    <updated>2018-04-30T18:02:10.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-입문"><a href="#React-입문" class="headerlink" title="React 입문"></a>React 입문</h1><p>미리 밝히자면 아래 내용은 결과론적일 수 있고, 필자의 개인적인 추측들이 담겨있으며, 마지막으로 필자는 Angular 또는 Vue로 프로젝트를 해본 경험이 전혀 없습니다.</p><p>React는 Anti-Angular 목적이 담긴 라이브러리였다고 생각합니다.</p><p>예전에는 React에서 내세웠던 3가지 가치가 아래와 같았습니다.</p><p><code>Just the UI</code>, <code>Virtual DOM</code>, <code>Data Flow</code></p><p>첫 번째 내세운 가치인 Just the UI 는, Angular가 풀려는 문제가 매우 크고 그에 따른 해결책도 복잡했기에, React는 매우 단순하며 쉬운 <code>라이브러리</code>라는 점을 대단히 강조하고 싶었던 것 같습니다.</p><p>두 번째인 Virtual DOM은 Angular가 Digest Loop를 통해 변경사항을 반영했다면, React는 Virtual DOM을 통해서 효과적으로 Diff를 반영한다는 것을 내세우고 싶었던 것 같습니다.</p><p>마지막으로 Data Flow 역시 Angular는 Model-View 간의 양방향 바인딩을 지원했던 것에 비해, React는 단방향으로 Data의 변화를 View에 반영시키는 점도 Angular의 복잡성에 대한 차별성으로 나온 것이 아닐까 싶습니다.</p><p>최근에 React 공식 사이트가 Gatsby로 개편되면서 내용에도 일부 변화가 있었는데, 내세우는 3가지 가치가 아래와 같이 바뀌었습니다.</p><p><code>Declarative</code>, <code>Component-Based</code>, <code>Learn Once, Write Anywhere</code></p><p>첫 번째에서 말하는, 선언적인 View가 가능하다는 점은 제가 생각하는 React의 가장 큰 장점입니다.</p><p>Vanila나 jQuery로 개발했다면, Event Listener를 Delegation해놓고, 해당하는 Event Handler를 절차적으로 작성하여 User Interaction 또는 Data의 변화에 따른 View 수정을 했어야 했을 것입니다.</p><p>그에 비해서 React는 Component에 작성해놓은 방향대로 변화(User Interaction, Data Change)가 View에 반영되도록 돕습니다.</p><p>두 번째에서 말하는 Component는 굳이 언급이 필요했는지에 대해 잘 모르겠습니다. (React의 고유한 특징이라고 보기는 어려우므로) 오히려 하단에 적혀있는 아래 문구에 좀 더 방점이 찍혀있는 것인가 싶습니다.</p><blockquote><p>Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM.</p></blockquote><p>마지막으로 Learn Once, Write Anywhere 역시 의미를 알기 어려웠는데, React Native 또는 React VR 등을 염두해두고 작성한 것인가 싶습니다.</p><p>어떤 라이브러리나 프레임워크를 사용할지 여부를 판단하기 위해 꼭 참고해야 할 Marketing Copy를 기준으로 React를 돌아보았습니다. 제가 알지 못하는 뒷배경들이 많겠지만, 적어도 제게는 예전 문구들이 훨씬 더 매력적이었던 것 같습니다.</p><p>실제로 React를 사용하기 위해선 Props, State, setState, Presentation Component, Container Component, Life Cycle, State Management, CRA, Webpack, SSR 등 알아야 할 것들이 많지만 해당 요소들은 다른 글을 통해 알아보기로 하겠습니다.</p><p>글에 대한 피드백은 언제든 환영합니다! :D</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-입문&quot;&gt;&lt;a href=&quot;#React-입문&quot; class=&quot;headerlink&quot; title=&quot;React 입문&quot;&gt;&lt;/a&gt;React 입문&lt;/h1&gt;&lt;p&gt;미리 밝히자면 아래 내용은 결과론적일 수 있고, 필자의 개인적인 추측들이 담겨있으며
      
    
    </summary>
    
      <category term="React" scheme="https://JeewhanR.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://JeewhanR.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title> 파이썬 기초</title>
    <link href="https://JeewhanR.github.io/2018/03/07/2018-03-07-Python-Basic/"/>
    <id>https://JeewhanR.github.io/2018/03/07/2018-03-07-Python-Basic/</id>
    <published>2018-03-06T16:44:12.612Z</published>
    <updated>2018-04-30T18:03:06.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="파이썬-기초"><a href="#파이썬-기초" class="headerlink" title="파이썬 기초"></a>파이썬 기초</h3><hr><p>1일차</p><ul><li>자료형</li><li>제어문</li><li>입력과 출력</li><li>함수</li><li>PEP8</li></ul><h5 id="자료형과-자료구조는-무엇이-다른가"><a href="#자료형과-자료구조는-무엇이-다른가" class="headerlink" title="자료형과 자료구조는 무엇이 다른가?"></a>자료형과 자료구조는 무엇이 다른가?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">자료형 = Data Type / 프리미티브 타입(파이썬에서 이미 구현이 완료되어있는 애들) / 숫자, 문자, 리스트, 튜플, 딕셔너리, 셋 등</span><br><span class="line">자료구조 = Data Structure / 데이터를 저장하는 방식 / 배열, 집합, 키-값 등</span><br><span class="line">자료구조중 일부들이 자료형으로 이미 구현되어있음</span><br><span class="line">배열 = 리스트, 집합 = 셋, 키-값 = 딕셔너리</span><br><span class="line">그 언어는 어떤 자료형을 제공하고 있는지를 이해하는 것이 매우 중요합니다</span><br><span class="line">또한 컴퓨터 분야 전반에서는 어떤 자료구조를 쓰고 있는가 에 대한 파악하는 것이 매우 중요하다</span><br></pre></td></tr></table></figure><h5 id="자료형"><a href="#자료형" class="headerlink" title="자료형"></a>자료형</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number : 정수, 실수, 복소수, 8진수, 16진수 등</span><br><span class="line">String : 문자 또는 문자열</span><br><span class="line">List : 순서가 있는 여러 요소들의 모음</span><br><span class="line">Tuple : 리스트와 동일하지만, 불변</span><br><span class="line">Dict : 키와 값이 연결되어있는 구조</span><br><span class="line">Set : 순서가 없는 유니크 element들의 모음</span><br><span class="line">Boolean : 참 또는 거짓</span><br></pre></td></tr></table></figure><h5 id="파이썬-연산"><a href="#파이썬-연산" class="headerlink" title="파이썬 연산"></a>파이썬 연산</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a += <span class="number">1</span>   <span class="comment"># a에 1을 더해서 a에 할당</span></span><br><span class="line">a ** <span class="number">2</span>   <span class="comment"># a^2</span></span><br><span class="line"><span class="number">14</span> // <span class="number">3</span>  <span class="comment"># 몫</span></span><br><span class="line"><span class="number">14</span> % <span class="number">3</span>   <span class="comment"># 나머지</span></span><br></pre></td></tr></table></figure><ul><li>자료형<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 변수명은 소문자</span></span><br><span class="line"><span class="comment"># room_size = Under Line / roomSize = CamelCase</span></span><br><span class="line"><span class="comment"># 파이썬에서는 변수명으로 무조건 Under Line 사용</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type(변수명) : 변수의 타입을 알려준다</span></span><br><span class="line"><span class="comment"># int(변수명) : 변수의 타입을 정수형태로 변경 / list(), set()</span></span><br><span class="line"></span><br><span class="line">animals = [<span class="string">"강아지"</span>, <span class="string">"고양이"</span>, <span class="string">"이구아나"</span>, <span class="string">"물고기"</span>, <span class="string">"참새"</span>]</span><br><span class="line"><span class="comment"># 하나씩 출력을 하다가, index가 2번인 경우 파이썬으로 변경하자</span></span><br><span class="line"><span class="comment"># name[0] : name 변수에서 0번 째만 추출</span></span><br><span class="line"><span class="comment"># name[1:] : 첫 번째부터 맨 끝까지 추출</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 문자열 중간에 변수의 값을 넣는 방법</span></span><br><span class="line"><span class="comment"># https://pyformat.info/</span></span><br><span class="line"></span><br><span class="line"><span class="string">"%s님 안녕하세요."</span> % (<span class="string">"안수찬"</span>)</span><br><span class="line"><span class="string">"&#123;0&#125;님 안녕하세요."</span>.format(‘안수찬’)</span><br><span class="line"><span class="string">"&#123;name&#125;님 안녕하세요."</span>.format(name=<span class="string">"안수찬"</span>)</span><br><span class="line"><span class="string">"안녕하세요. &#123;name&#125; 입니다. 저는 &#123;course&#125; 를 수강하고 있습니다."</span>.format(name=안수찬, course=<span class="string">"데사스"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 주석처리</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List : 순서가 있는 요소들, 변경 가능</span></span><br><span class="line">animals = [<span class="string">"강아지"</span>, <span class="string">"고양이"</span>, <span class="string">"이구아나"</span>]</span><br><span class="line">animals.append(<span class="string">"물고기"</span>)</span><br><span class="line">animals[<span class="number">0</span>][<span class="number">0</span>] <span class="comment"># 강아지</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple : List와 동일하지만, Element 값이 변경이 될 수 없다</span></span><br><span class="line">width_and_height = (<span class="number">120</span>, <span class="number">240</span>)</span><br><span class="line">width, height = width_and_height</span><br><span class="line">width = <span class="number">120</span></span><br><span class="line">height = <span class="number">240</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set : 집합, 순서가 없고, Unique한 값만 담길 수 있다, 중복 제거용</span></span><br><span class="line">name_set = set([<span class="string">"안수찬"</span>, <span class="string">"안수찬"</span>, <span class="string">"김승현"</span>, <span class="string">"박승권"</span>])</span><br><span class="line">name_set == &#123;‘김승현’, ‘박승권’, ‘안수찬’&#125;</span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">"안수찬"</span>, <span class="string">"안수찬"</span>, <span class="string">"안수찬"</span>, <span class="string">"김승현"</span>, <span class="string">"김승현"</span>, <span class="string">"김승현"</span>, <span class="string">"박준영"</span>, <span class="string">"박준영"</span>, <span class="string">"박준영"</span>]</span><br><span class="line">name_list = list(set(name_list)) <span class="comment"># 파이썬다운 중복을 제거하는 방법이되, 순서를 보장하지는 않음</span></span><br><span class="line">name_list == [‘김승현’, ‘안수찬’, ‘박준영’]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean</span></span><br><span class="line"><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line"><span class="comment"># 특정 조건에서 작동하도록 설정할 때, 매우 많이 사용될 것</span></span><br><span class="line"><span class="comment"># &amp; 나 | 보다는 and 또는 or로 쓰는 것이 보다 명시적이다</span></span><br><span class="line"><span class="comment"># and 와 or가 섞여있어야 한다면, 좀 더 직관적인 프로세스를 만들어보거나 ( )로 전후를 구분해줄 것</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dict : 키와 값을 쌍으로 묶은 것, 다른 곳에서는 Dict, Hash, JSON 등으로 쓰임</span></span><br><span class="line"><span class="comment"># :은 키에 붙여야 한다</span></span><br><span class="line"><span class="comment"># 함수 안에 키-밸류 형태로 넣을 때는 띄어쓰기를 하지 않는다</span></span><br><span class="line">detail_dict = &#123;<span class="string">"name"</span>: <span class="string">"안수찬"</span>, <span class="string">"age"</span>: <span class="number">24</span>, <span class="string">"phone number"</span>: <span class="string">"010-1234-5678"</span>&#125;</span><br><span class="line">detail_dict[<span class="string">"age"</span>] == ‘안수찬<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my_informations = &#123;"name": "dobestan", "phonenumber": "010-1234-5678", "email": "test@gmail.com"&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="반복문과-제어문"><a href="#반복문과-제어문" class="headerlink" title="반복문과 제어문"></a>반복문과 제어문</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">3</span>:</span><br><span class="line">     print(<span class="string">"1이 3보다 작다."</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">13</span></span><br><span class="line">b = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; b:</span><br><span class="line">     print(<span class="string">"a(&#123;a&#125;)가 b(&#123;b&#125;)보다 작다."</span>).format(a=a, b=b))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     print(<span class="string">"a가 b보다 크다."</span>).format(a=a, b=b))</span><br><span class="line">     </span><br><span class="line">animals = [<span class="string">"강아지"</span>, <span class="string">"고양이"</span>, <span class="string">"이구아나"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">"이구아나"</span> <span class="keyword">in</span> animals:</span><br><span class="line"></span><br><span class="line">     print(<span class="string">"이구아나를 키우고 있습니다."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     print(<span class="string">"이구아나를 키우고 있지 않습니다."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 90점 이상은 A</span></span><br><span class="line"><span class="comment"># 60 ~ 90점까지는 B</span></span><br><span class="line"><span class="comment"># 60점 밑으로는 C</span></span><br><span class="line">score = <span class="number">89</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">     print(<span class="string">"A"</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">     print(<span class="string">"B"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     print(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 제어문 : 특정 조건 또는 반복적으로 코드를 실행</span></span><br><span class="line"><span class="comment"># for : while문보다 통제가 수월하고 직관적이기에 더 선호됨</span></span><br><span class="line"><span class="comment"># for문을 사용할 때 많이 사용할, range라는 내장함수를 제공한다</span></span><br><span class="line">list(range(<span class="number">10</span>)) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">animals = [<span class="string">"강아지"</span>, <span class="string">"고양이"</span>, <span class="string">"참새"</span>, <span class="string">"이구아나"</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">     print(<span class="string">"나는 &#123;animal&#125;를 키운다."</span>.format(animal=animal))</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">     print(<span class="string">"hello world &#123;number&#125;"</span>.format(number=number))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 변수를 for문 내에서는 사용하지 않을 때 _ 를 써줌</span></span><br><span class="line">     print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while : Python에서는 for문을 더 선호함, 덜 직관적이기 때문, 지속적 통제가 요구됨</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">while</span> age &lt; <span class="number">30</span>:</span><br><span class="line">    print(<span class="string">"20대에 나이를 먹었습니다. 현재 나이 : &#123;age&#125;"</span>.format(age=age))</span><br><span class="line">    age += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *</span></span><br><span class="line"><span class="comment"># **</span></span><br><span class="line"><span class="comment"># ***</span></span><br><span class="line"><span class="comment"># ****</span></span><br><span class="line"><span class="comment"># *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">     star = <span class="string">""</span></span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">          star += <span class="string">"*"</span></span><br><span class="line">     print(star)</span><br><span class="line"></span><br><span class="line">star = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">     star += <span class="string">"*"</span></span><br><span class="line">     print(star)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">     print(<span class="string">"*"</span> * (i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">별찍기 과제</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">    *</span><br><span class="line">   **</span><br><span class="line">  ***</span><br><span class="line"> ****</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"> ****</span><br><span class="line">  ***</span><br><span class="line">   **</span><br><span class="line">    *</span><br><span class="line"></span><br><span class="line"># 별찍기 과제 해답</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(&quot;*&quot; * (i + 1))</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(&quot; &quot;* (4 - i) + &quot;*&quot; * (i + 1))</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(&quot;*&quot; * (5 - i))</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(&quot; &quot; * i + &quot;*&quot; * (5 - i))</span><br></pre></td></tr></table></figure><h5 id="입력과-출력"><a href="#입력과-출력" class="headerlink" title="입력과 출력"></a>입력과 출력</h5><ul><li>사용자 / 파일 / stdin ( standard input ) / stdout ( standard output )</li></ul><h5 id="사용자로부터-인풋-받기"><a href="#사용자로부터-인풋-받기" class="headerlink" title="사용자로부터 인풋 받기"></a>사용자로부터 인풋 받기</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username = input(<span class="string">"너의 이름은 뭐니? "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(int(input(<span class="string">"별 몇개? "</span>))):</span><br><span class="line">     print(<span class="string">"*"</span> * (i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h5 id="Python-3-VS-Python-2"><a href="#Python-3-VS-Python-2" class="headerlink" title="Python 3 VS Python 2"></a>Python 3 VS Python 2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Python 3.X =&gt; input (…), print(…)</span><br><span class="line">input은 항상 str으로 정보를 받아온다</span><br><span class="line">Python 2.X =&gt; input을 받은 정보를 파이썬으로 실행하려고 함</span><br><span class="line">TEXT를 받고자 하면 raw_input 을 사용해야 함</span><br><span class="line"></span><br><span class="line">Python 3.X =&gt; print 는 함수 / print(&quot; &quot;)</span><br><span class="line">Python 2.X =&gt; print 는 statement, 출력하는 기능 / print &quot; &quot;</span><br><span class="line"></span><br><span class="line">Unicode is a character set. ( 표준 문자열 집합 )</span><br><span class="line">UTF-8 is an encoding. ( 유니코드를 표현할 수 있는 인코딩 방식 )</span><br><span class="line">Unicode를 표현하는 방식 중 하나가 utf-8</span><br><span class="line">Unicode를 encoding하는 방식이 utf-8</span><br><span class="line">utf-8을 decode하면 Unicode</span><br><span class="line">한글은 일반적으로 UTF-8 or EUC-KR ( 거의 대부분은 UTF-8 사용 )</span><br><span class="line"></span><br><span class="line">Python 2.X =&gt; 기본 인코딩이 ascii여서 한글 작성시에 문제가 발생</span><br><span class="line">그래서 아래와 같이 붙여놔야 함</span><br><span class="line">-*- coding: utf-8 -*-</span><br><span class="line">( 위 문장이 추가되면 읽을 때 str이 utf-8로 인코딩되었다고 인지한다 )</span><br><span class="line"></span><br><span class="line">하지만 위 문장이 있다고 해서 decode, encode하는 과정에서의 default setting이 ascii가 아니게 되는 것은 아니므로 아무런 옵션 지정없이 decode, encode를 하게 되면 ascii 방식으로 인코딩되어서 에러가 발생하게 된다</span><br><span class="line"></span><br><span class="line">( 파이썬에서는 문자열을 표현할 수 있는 str, unicode 타입을 제공한다 )</span><br><span class="line">print(type(&apos;한글&apos;)) =&gt; str</span><br><span class="line">print(type(u&apos;한글&apos;)) =&gt; unicode</span><br><span class="line"></span><br><span class="line">에러 예시: print str(unicode(&quot;한글&quot;))</span><br><span class="line">참 예시: print &quot;한글&quot;.decode(&quot;utf8&quot;) =&gt; unicode</span><br><span class="line">참 예시: print &quot;한글&quot;.decode(&quot;utf8&quot;).encode(&quot;utf8&quot;) =&gt; str</span><br><span class="line"></span><br><span class="line">unicode로 인코딩 되어있으면 str으로 저장됨</span><br><span class="line">unicode로 인코딩 되어있지 않으면 unicode로 저장됨</span><br><span class="line">(하지만 unicode를 print 할 때는 자동적으로 utf-8로 변환함)</span><br><span class="line"></span><br><span class="line">다른 사람들이 작성한 파일을 쓸 때는, Python 기본 인코딩을 ascii에서 utf8로 변경해주면 된다</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">Python 2.X 에서 한글 문제 없이 사용하기</span><br><span class="line">1. 파일 상단에 -*- coding: utf-8 -*- 명시</span><br><span class="line">2. 파이썬 스크립트 내에서는 반드시 unicode 로 변경해서 사용</span><br><span class="line">3. 외부 파일을 읽거나 쓸 때는 str 로 변경해서 읽거나 쓴다</span><br><span class="line">4. 외부 라이브러리를 쓸 떄는 setdefaultencoding 을 사용해서 기본적으로 utf-8 사용</span><br><span class="line"></span><br><span class="line">Python 3.X 는 모든 문자열이 unicode 이기에 인코딩에 대해 고민할 필요없음</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Indent로 포함관계 구분</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(animals)):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        animals[<span class="number">2</span>] = <span class="string">"파이썬"</span></span><br><span class="line">    print(animals[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    index = animals.index(animal)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">2</span>:</span><br><span class="line">        animals[index] = <span class="string">"파이썬"</span></span><br><span class="line">    print(animals[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, _ <span class="keyword">in</span> enumerate(animals):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">2</span>:</span><br><span class="line">        animals[index] = <span class="string">"파이썬"</span></span><br><span class="line">    print(animals[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> my_information <span class="keyword">in</span> my_informations:</span><br><span class="line">    print(my_information)</span><br><span class="line">    print(my_informations[my_information])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> my_information <span class="keyword">in</span> my_informations.items():</span><br><span class="line">    print(my_information) <span class="comment"># Tuple</span></span><br><span class="line">    key, value = my_information</span><br><span class="line">    print(key)</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_informations.items():</span><br><span class="line">    print(key)</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">my_informations.keys()</span><br></pre></td></tr></table></figure><hr><h5 id="파일-입출력"><a href="#파일-입출력" class="headerlink" title="파일 입출력"></a>파일 입출력</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./ =&gt; 현재 폴더</span></span><br><span class="line"><span class="comment"># ../ =&gt; 상위 폴더</span></span><br><span class="line"><span class="comment"># ./test.txt =&gt; 현재 폴더에 있는 test.txt</span></span><br><span class="line"><span class="comment"># ../test.txt =&gt; 상위 폴더에 있는 test.txt</span></span><br><span class="line"><span class="comment"># ../../test.txt =&gt; 상위 폴더의 상위 폴더에 있는 test.txt</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"../animals.txt"</span>, <span class="string">"r"</span>) <span class="comment"># mode =&gt; "w", "r", "a" ( append )</span></span><br><span class="line"><span class="comment"># f.read() =&gt; 파일의 전체 데이터</span></span><br><span class="line"><span class="comment"># f.readline() =&gt; 실행할 때마다 행이 바뀌어 출력</span></span><br><span class="line"><span class="comment"># f.readlines() =&gt; 각각의 라인별로 구분되어 리스트</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"./animals.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">f.write(<span class="string">"hello, world"</span>)</span><br><span class="line">f.close</span><br><span class="line"></span><br><span class="line"><span class="comment"># 위와 동일하지만 보다 선호되는 방식</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./animals.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">".stars.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        f.write(<span class="string">"*"</span> * (i + <span class="number">1</span>))</span><br><span class="line">        f.write(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><hr><h4 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h4><ul><li>작업 자동화</li><li>우리가 반복적으로 사용할 어떤 특정 기능들을 재사용 가능한 코드로 작성</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">()</span>:</span></span><br><span class="line">    username = input()</span><br><span class="line">    print(<span class="string">"&#123;username&#125;님, 가입을 축하드립니다."</span>.format(username=username))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">greeting()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_pretty_star</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    이 함수는 별찍기 함수입니다.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">"*"</span> * (i))</span><br><span class="line"><span class="comment"># """ multi-line """ 로 내용을 적어두면 Docstring에 반영됨</span></span><br><span class="line"></span><br><span class="line">print_pretty_star(<span class="number">5</span>)</span><br><span class="line">print_pretty_star(int(input(<span class="string">"Count?"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 내에 return은 함수가 반환하는 결과값을 의미 + 그 순간 함수는 종료</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수에 어떤 숫자를 입력했을 때, 그 이하의 소수를 출력해주는 함수</span></span><br><span class="line"><span class="comment"># 수업 전에 내가 짠 코드</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime_numbers</span><span class="params">(number)</span>:</span></span><br><span class="line">    prime_numbers = []</span><br><span class="line">    <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"소수가 없습니다."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">            bool = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span> <span class="keyword">and</span> i != j:</span><br><span class="line">                    bool = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> bool == <span class="keyword">True</span>:</span><br><span class="line">                prime_numbers.append(i)</span><br><span class="line">        print(prime_numbers)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 수업 코드</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1차</span></span><br><span class="line"><span class="comment"># 우선 한 번에 모든 기능을 구현하는 것은 복잡하니,</span></span><br><span class="line"><span class="comment"># 각각의 과정들을 기능별로 나누어서 접근하라</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 각각의 숫자의 소수여부를 검사해서 =&gt; is_prime</span></span><br><span class="line"><span class="comment"># 소수면 리스트에 추가하고 최종적으로는 리스트를 출력 =&gt; get_prime_numbers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="comment"># 2부터 number-1 까지의 숫자를 각각 체크해본다.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number):</span><br><span class="line">        <span class="keyword">if</span> (number % i == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime_numbers</span><span class="params">(number)</span>:</span></span><br><span class="line">    prime_numbers = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime(i):</span><br><span class="line">            prime_numbers.append(i)</span><br><span class="line">    <span class="keyword">return</span> prime_numbers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 걸린 시간 측정하는 법</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">get_prime_numbers(<span class="number">1000</span>)</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(end_time - start_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2차 제곱근까지만 체크( 다른 방법: 홀수만 체크, 2로 나누어 떨어지는 숫자까지 체크 )</span></span><br><span class="line"><span class="comment"># 소수로 확인된 것의 배수를 모두 지우는 방법도 있음 =&gt; 에라토스테네스의 체</span></span><br><span class="line"><span class="comment"># 알고리즘에 대해서는 수학적으로 이미 증명된 것들이 매우 많기 때문에 검색해서 활용해볼 것</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime_optimized</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(number**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (number % i == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://goo.gl/N5QltM</span></span><br><span class="line"><span class="comment"># 에라토스테네스의 체 구현 코드</span></span><br><span class="line">    <span class="comment">#결과 값을 저장하는 목록을 미리 생성한다.</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment">#전체 범위를 지정한다. : 1은 소수임을 알고 있으므로 제외하고 2부터 수행해야 하지만 초기값은 별도로 생성할 것이므로 3부터 999까지의 범위로 한다.</span></span><br><span class="line">    candidates = range(<span class="number">3</span>,<span class="number">1000</span>)</span><br><span class="line">    <span class="comment">#초기값을 설정한다.</span></span><br><span class="line">    base = <span class="number">2</span></span><br><span class="line">    <span class="comment">#초기값의 배수를 구하기 위한 임시 변수를 생성한다.</span></span><br><span class="line">    product = base</span><br><span class="line"></span><br><span class="line"><span class="comment">#전체 범위 내에서 "에라토스테네스의 체" 알고리즘을 수행한다.</span></span><br><span class="line">    <span class="keyword">while</span> candidates:</span><br><span class="line">        <span class="comment">#임시변수가 1000미만일 때까지 다음을 수행한다.</span></span><br><span class="line">        <span class="keyword">while</span> product &lt; <span class="number">1000</span>:</span><br><span class="line">            <span class="comment">#임시변수가 전체 범위내 존재한다면 :</span></span><br><span class="line">            <span class="keyword">if</span> product <span class="keyword">in</span> candidates:</span><br><span class="line">                <span class="comment">#전체 범위 목록에서 임시변수를 삭제한다.</span></span><br><span class="line">                candidates.remove(product)</span><br><span class="line">            <span class="comment">#임시변수는 기본값의 배수이다.</span></span><br><span class="line">            product = product+base</span><br><span class="line">        <span class="comment">#결과 목록에 기본값을 추가한다.</span></span><br><span class="line">        result.append(base)</span><br><span class="line">        <span class="comment">#다음 기본값은 (이미 걸러진)전체 목록의 첫 번째 값이다. : 1회 걸렀을 경우 2와 2의 배수를 모두 삭제했으므로 3이다.</span></span><br><span class="line">        base = candidates[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#초기값의 배수를 구하기 위해 임시 변수를 다시 생성한다.</span></span><br><span class="line">        product = base</span><br><span class="line">        <span class="comment">#전체 범위에서 초기값을 제거한다.</span></span><br><span class="line">        <span class="keyword">del</span> candidates[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 범위 내의 마지막 기본값을 결과 목록에 추가한다.</span></span><br><span class="line">    result.append(base)</span><br><span class="line">    <span class="comment">#결과 목록을 화면에 출력한다.</span></span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><hr><h5 id="안수찬-선생님의-조언"><a href="#안수찬-선생님의-조언" class="headerlink" title="안수찬 선생님의 조언"></a>안수찬 선생님의 조언</h5><ul><li>생각하면 실행해본다, 실행력이 매우 중요</li><li>개발자 영어는 충분히 할 수 있는 영역</li><li>실력을 늘리는 가장 주요한 방법은 외주개발</li><li>시간을 팔아서 돈을 버는 것을 지양하자</li><li>코드카데미, 팀트리하우스 에서 열심히 수강해보자</li><li>역량을 증명하기 전까지는 후려침을 겪을 수 밖에 없다</li></ul><h5 id="내가-개발자-성향을-가지고-있는가"><a href="#내가-개발자-성향을-가지고-있는가" class="headerlink" title="내가 개발자 성향을 가지고 있는가?"></a>내가 개발자 성향을 가지고 있는가?</h5><ul><li>개발자 성향이란?<ul><li>문제 해결에 대한 집요함 = 문제를 중간에 포기하지 않고 끝까지 해결하려 하는가</li><li>문제해결력 = 상당 부분 연습으로 극복가능</li></ul></li></ul><h5 id="파이썬-관련-추천도서"><a href="#파이썬-관련-추천도서" class="headerlink" title="파이썬 관련 추천도서"></a>파이썬 관련 추천도서</h5><ul><li>깐깐하게 배우는 파이썬</li><li>실전 파이썬 프로그래밍</li><li>Two Scoops of Django</li><li>클린 코드를 위한 테스트 주도 개발</li><li>파이썬 라이브러리를 활용한 데이터 분석 = 데이터 분석이 필요하다면 기본서</li><li>Udemy - Learning Python for Data Analysis and visualization</li></ul><h5 id="왜-파이썬인가"><a href="#왜-파이썬인가" class="headerlink" title="왜 파이썬인가?"></a>왜 파이썬인가?</h5><ul><li>개발을 처음 배우는 이에게 가장 제대로 기본을 다질 수 있는 언어</li><li>파이썬을 완벽히 하는 것이 매우 중요하다, 그래야만 범용적 개발을 해나갈 수 있다</li><li>Pandas는 R스러운 파이썬 패키지</li><li>모든 언어를 익힐 때 가장 먼저 배워야 할 것은 문화이다</li></ul><h5 id="기타-팁"><a href="#기타-팁" class="headerlink" title="기타 팁"></a>기타 팁</h5><ul><li>jupyter 또는 ipython 은 ?변수 라고 입력하면 자세히 안내해준다</li><li>모르는 함수들은 늘 ?를 입력해보는 습관을 들일 것</li><li>Google, Facebook, Jupyter 모두 Vim 단축키들이 작동함</li><li>파이썬은 고수준 작업에 많이 사용되다보니 비트연산을 자주 사용하지는 않음(연산자는 &gt;&gt; or &lt;&lt;)</li><li>= 와 + 은 양쪽을 띄워줘야 한다</li><li>폴더명 등의 자동완성은 이용할만 하지만, 명령어 등은 자동완성하기 보다는 직접 타이핑하는 것을 권한다</li><li>언어의 철학에 따라 변수 지정, 패턴 등이 달라져야 한다</li><li>계속해서 Zen을 떠올리면서 코딩을 해야 한다</li><li>Docker 가상 환경 = 환경만 그렇게 보이도록 한 것, 속도가 빠름</li><li>Parallels = 가상 머신</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;파이썬-기초&quot;&gt;&lt;a href=&quot;#파이썬-기초&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초&quot;&gt;&lt;/a&gt;파이썬 기초&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1일차&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자료형&lt;/li&gt;
&lt;li&gt;제어문&lt;/li&gt;
&lt;li&gt;입력과 출력
      
    
    </summary>
    
      <category term="Python" scheme="https://JeewhanR.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://JeewhanR.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
