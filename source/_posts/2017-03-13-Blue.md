---
layout: post
title: "CodeSquad Blue Level"
date: 2017-03-13 10:00:00 +0900
categories: CodeSquad
---

```
<JK's Intro>
서양에서는 물질을 주어로 두고 많이 생각해요
(Arrival, 새로 물건이 도착, 새출발)

언어를 배우려면, 그 문화처럼 사고해야 된다

공학적 사고방식
문제 정의 -> 자료 수집 -> 해결 아이디어 도출 -> 접근 방법 토론 -> 실험 -> 문제 정의

compute: 함께 해결하다

팀프로젝트가 중요하다

목표 달성을 위해 자기에게 잘 맞는 도구를 찾아보세요

동기부여(함축적인 문장), 목표설정(장기 목표와 그것을 세분화하고 달성 여부를 측정 가능한 단기목표), 집중력(심성모델과 직관적인 예측), 정보습득(기록, 가공, 검증, 설득)

어렵게 기록해야 자기 것이 된다

의식의 4단계
- 무의식적 무지(Unconscious Not Knowing), 무엇을 모르는지 알지 못한다, 즐길 수는 있다
- 의식적 무지(Consccious Not Knowing), 무엇을 모르는지 알고 배우기 시작, 즐길 수 없음
- 의식적 지식(Conscious Knowing), 지식을 배워가면서 다른 분야로 확장하고 업적이 쌓임, 여전히 즐겁지 않음
- 무의식적 지식(Unconscious Knowing), 의식하지 않고 직감적으로 움직이며 즐길 수 있다

마음 먹기에 따라 2~3단계를 얼른 벗어날 수 있어요, 4단계로 가는 것에는 마음 가짐이 중요해요

Act Fast, Start Small and Scale Big.

<Honux's Intro>
한국 사람들은 반갑습니다 라고 하면 박수를 쳐요(웃음)

수업에 적극적으로 임할 것, 어려우면 질문에 대해서 속으로라도 대답해볼 것

무턱대고 쓸 수 있는 무엇인가를 만드는 것이 최선이에요

지식 학습과 만드는 것을 적절히 배합해보세요

전부 다 공부해서 만들려고 하지 마세요
만들다가 궁금하면 그 부분만 공부하자
불필요하게 미래를 예측해서 잉여를 만들지 말자, 당장 필요한 그것만을 만들어라
필요할 것 같은 것은 공부하지 마세요, 필요한 것만 공부하세요

면접을 잘 보려면, 눈치를 보고 상대방이 좋아할 행동을 해야 합니다

매일 스스로 잘해보자고 다독여보아요

혼자 하다가 안 되면 학원에서 그만두곤 해요, 주변 사람들과 친하게 지내세요
멘탈 관리는 필수에요, 즐겁게 지내세요

코드리뷰에서 도망가지 마세요
코드를 자식과 같이 소중히 여기지 마세요, 여러분이 더 소중합니다
리뷰가 제일 중요합니다
아무것도 못 했어요 도 괜찮으니까 나오세요
그래야 살아남을 수 있습니다

개발자는 늘 공부해야 합니다

개발자들 중에 영어 못 하는 사람이 많으니, 훌륭한 개발자가 되는 것보다 영어를 적당히 할 줄 아는 개발자가 되는 것이 쉽습니다
하루에 1분이라도 하세요, 10분은 해야지 라고 생각하시면 결국 안 하게 되어요
밤샐 수 있는 체력을 쌓을 수 있게 운동하세요
세상, 한국, 민주주의를 구하려고 하지 말고, 우선 나부터 구하세요

동영상을 혼자 보려고 하지 말고, 같이 계획세워서 진도체크하세요
SNS를 의지를 북돋는 용도로 활용하세요, 선 선언 -> 후 행동
모든 인간은 의지가 전혀 없어요
의지 강화를 위해 다양한 장치를 활용하세요

<Crong's Intro>
많은 것을 얕게 알기 보다는 좁은 것을 깊게 할 줄 아는 것이 중요합니다
다 잘 하려고 하지 마세요, 면접에서 3번 정도 파고 들면 다 모르게 되어요
너무 많은 욕심을 가지지 마세요

한 달 이내의 기간 내에 시니어와 같이 프로젝트에 기여할 수 있을 것

많이 아는 것은 중요치 않고, 할 줄 있는 것들이 중요하다
리팩토링을 할 줄 아는 것이 중요해요 (동일 기능, 더 나은 성능)
협업과 공유를 할 수 있어야 해요, 피하지 마셔요

갈수록 고민이 깊어져야 합니다

미션수행, 동료평가, 결과물평가, 현장의 실무자 평가로 수료 여부를 결정할 것 같아요

깃헙 관리를 정말 빡세게 하셔야 해요요

<Git 강의>
몰랐던 부분
git commit 파일명 -m "Update" 처럼 적으면 add된 것들 중에 특정 파일만 커밋할 수 있음
git commit -am "Update" 라고 적으면 add와 동시에 커밋 가능

Commit Message
- 한 줄로 설명할 수 있는 단위로 커밋
- 어떻게 보다는 무엇과 왜를 설명
- 첫 줄 외에 나머지 줄에 항상 자세히 기록

주석에 대해서도 자기만의 가치관을 가지는 것이 좋아요
(정답이 없는 부분이기 때문에!)

참여하게 되는 프로젝트에서 사용하는 방식을 보고 따라하세요!
라이브러리인지, 서비스인지에 따라서도 크게 달라요!
규칙을 준수하는 것이 중요해요
커밋을 기준으로 릴리즈 노트(Change Log)를 만들곤 해요
하위 호환성을 유지하는 것은 마이너, 호환성이 깨질 수도 있는 것은 메이저

git branch -b : 새로운 브랜치를 만들면서 그리로 checkout
git branch : 브랜치 목록 보기
git merge dev_1.2 : 지금 있는 브랜치에 dev_1.2 브랜치를 merge함
git tag 1.2 : 현재 시점에 대해 1.2라는 태그를 달아줌
git branch -d dev_1.2 : dev_1.2 브랜치를 삭제함

협업할 때는 자주 Merge해주면서 늘 서비스가 동작되는 상태를 유지하면서 개발해야 합니다

git push --tags 를 통해 모든 태그를 푸시 가능
https://blog.outsider.ne.kr/644

우선 돌아가게 하고, 그 다음에 개선하셔요

Branch도 작명법이 있어요
master branch는 최신 배포버전을 유지해요!
태그를 기준으로 다운로드받도록 할 수도 있어요

네이버 메인에서 class명에 "-" 또는 "_"가 들어간 것이 몇개인지 찾으세용!
```

```javascript
// includes 사용
function solution(tag) {
  const tagList = document.querySelectorAll(tag);
  let result = 0;

  for (let i = 0, max = tagList.length; i < max; i++) {
    if (tagList[i].className.includes("-") || tagList[i].className.includes("_")) {
      result += 1;
    }
  }

  console.log(result);
}

// 정규표현식 test 사용
function solution(tag) {
  const tagList = document.querySelectorAll(tag);
  let result = 0;

  for (let i = 0, max = tagList.length; i < max; i++) {
    if (/[-_]/g.test(tagList[i].className)) {
      result += 1;
    }
  }

  console.log(result);
}

solution("div");

// 해당 조건에 맞는 ClassName 삭제하기
function solution(tag) {
  const tagList = document.querySelectorAll(tag);

  for (let i = 0, max = tagList.length; i < max; i++) {
    if (/[-_]/g.test(tagList[i].className)) {
      for (let j = 0, maxi = tagList[i].classList.length; j < maxi; j++) {
        if (/[-_]/g.test(tagList[i].classList[j])) {
          tagList[i].classList.remove(tagList[i].classList[j]);
        }
      }
    }
  }
}

solution("div");

// 함수 넘겨주는 버전
function remover(parent, child) {
  parent.classList.remove(child);
}

function solution(tag, remover) {
  const tagList = document.querySelectorAll(tag);

  for (let i = 0, max = tagList.length; i < max; i++) {
    if (/[-_]/g.test(tagList[i].className)) {
      for (let j = 0, maxi = tagList[i].classList.length; j < maxi; j++) {
        if (/[-_]/g.test(tagList[i].classList[j])) {
          remover(tagList[i], tagList[i].classList[j]);
        }
      }
    }
  }
}

solution("div", remover);

// 위의 for문 두 개 도는 것을 피하기 위해, for문 중 하나는 remover로 넘겨주자!
```
---

## 170314

```
Template을 HTML 내 Script로 숨겨놓거나, Ajax로 가져와서 쓰는 방법이 있어요
foreach의 변수명은 value index object을 줄인 v i o를 많이 써요-

함수의 흐름을 손으로 그려보세요, 더 좋은 아이디어가 떠오르면 처음부터 다시 짜보세요

기능이 복잡할수록 재사용성은 당연히 떨어져요
춘호님의 명언 : 이벤트는 없어지지 않는 곳에 걸어야 함
```

---

## 170315

```
DOM 조작을 최소화하려는 노력을 하세요 (DOM을 탐색한 뒤, 지역변수에 담아두기 등)
Ajax를 통한 결과를 재사용할 수 있도록 하는 노력을 기울여보세요
코드를 짤 때는 사람이 알아보기 쉬운 코드를 짜는 것이 목표에요

DOMContentLoaded 이후에 querySelector를 사용해야 문제가 안 생겨요
위와 같이 하고 싶지 않다면, 미리 HTML를 script단에 만들어두면 되어요

DOMContentLoaded - the whole document (HTML) has been loaded.
load - the whole document and its resources (e.g. images, iframes, scripts) have been loaded.

DOM 조작을 하려는 것이라면 많이 느린 load보다는 DOMContentLoaded를 사용해보세요

실행되는 흐름을 쉽게 분석할 수 있도록 하려면, 아무 곳에서나 함수를 실행시키면 안 됩니당!

replace를 체이닝해서 사용할 수도 있어요
.replace().replace() 등

jQuery는 가능하면 쓰지 마세요

((doc, win) => {
  console.log(doc.body);
  let div = doc.querySelector("div");
  console.log(div);
})(document, window)

bind를 활용하면 전역변수를 줄일 수 있어요, 또한 this도 지정해줄 수 있어요!

항상 설정정보나 URL은 밖으로 빼놓으세요!

. 표기법으로 접근할 수 있으면 모두 객체다

함수도 변수에요

array에서 원본을 바꾸지 않으면서, 카피본을 만들 때도 const를 활용해보세요
const list = ['john', 'adele', 'hary'];
list2 = [].concat(list, "tiger");
list == list2

const를 쓰되, Error나면 let으로 바꾸셔요!

Closure는 Scope에요
세상에는 전역 Scope, 함수 Scope만 있는 것이 아니라 블록 Scope와 Closure Scope가 있는 거에요!
원래는 접근할 수 없었던 부모 Scope에 접근할 수 있게 된 것이에요!

Closure VS Let

Debugger를 통해서 문제 상황이 왜인지 파악해가는 것이 가장 중요해요!
문제를 해결해가는 과정이 중요하지, 그 각개 현상을 모두 외우는 것은 매우 어려워요!
Debugger를 잘 활용하는 것이 제일 중요해요!

Closure는 JS Scope와 관련한 문제라는 것을 기억하는 것이 가장 중요해요
부모 함수의 변수를 부모 함수가 끝나고도 계속 쓸 수 있게 한다!
(Functional Scope에 대한 극복 방안)

Let은 Closure와 달리 공유되지 않는 개별적 변수로 구분해주어요 (매 블록마다 구분하여 존재함)

해당 변수를 Share를 해야 한다면, Closure
해당 변수를 Share되지 않아야 한다면, Let

스코프는 선언될 때 결정되어요, 그래서 눈에 보일 때와 같아요

local -> block -> closure -> global

Currying 이라는 키워드로 찾아보셔요!
요새 RxJS라는 것도 있어요!

눈에 보이진 않지만, new를 하면 return this를 하게 되어요(Instance 생성)
new + 생성자 함수 => 새로운 객체
위와 같이 하면 생성자 함수에 있는 내용이 계속 복사되어 생겨난다

그렇게 하지 않으려면 Share할 수 있는 공간인 prototype을 활용하면 된다 (메모리 측면에서 효율적)

스코프처럼 프로토타입도 체이닝되어요

공통으로 사용하려면 prototype, prototype을 기반으로 각기 따로 관리하려면 new를 통한 생성
공통으로 사용하려면 var Closure, 각기 따로 관리되길 원하면 let Closure
let은 정의 당시의 그 변수 상황에 적용됨

Object 리터럴에서는 Arrow는 window를 가르키니까 쓰지마세요!

var testObj = Object.create(object);
new 대신에 위와 같은 방식으로 짜는 것이 완전 JS스러워서 정말 좋아요

var healthObj = {
showHealth : function() {
	console.log("오늘은 " + this.lastTime + "까지 " + this.name + " 운동을 하셨네요");
	}
}

실습 1에서 만든 코드를 Object.create로 변경하고, Closure에 대해서 정리해서 글을 적어보세요!
var myHealth = Object.create(healthObj);
myHealth.name = "달리기";
myHealth.lastTime = "23:10";
```

---

## 170316

```
심심하면 오픈소스 프로젝트에서 클래스를 어떻게 만드는지 찾아보세요
디버깅을 통해 브라우저의 동작원리를 파악해가는 방식이 정말 좋습니다!!!
이전에 짠 코드는 기능을 이해하기 위한 시도였다고 생각하고, 처음부터 다시 짜야한다고 생각하세요
시나리오를 짜고, 그 시나리오를 모두 통과할 수 있게 하는 설계나 테스트가 갖춰진 뒤에 구현에 들어가세요
```

---

## 170317

```
수행해야 할 로직이라면 무작정 추상화하기 보다는 명시적으로 보여주는 것도 좋을 것 같아요
똑같은 로직을 계속해서 다시 짜보는 과정을 블로깅해보세요
원래 이런 코드였는데, 이런 문제가 있어서 요렇게 새롭게 짜보았다 라고 사고를 드러내는 포스트, 박수쳐드릴게요
패턴과 같은 것들을 접할 때, 비판적 사고를 할 수 있어야 해요
요구사항에 따라서 구현해야 할 패턴이 달라질 수 밖에 없어요
늘 내 의도를 타인에게 얘기할 수 있어야 해요

var cs = {};
cs.view = {};
cs.model = {};

위와 같이 네임스페이스를 쓸 수 있어요

Object cache를 사용해보세요

반복적으로 template.secondTemplate 가 반복되면,
const st = template.secondTemplate; 와 같이 써보세요
이렇게 하면 입력도 편하고 탐색 비용이 선언할 때 한 번으로 줄어들기 때문에 매우 좋습니다

어떤 것 하나가 변경될 때, 영향력이 최대한 적도록 코딩을 해야 해요

컴포넌트의 핵심은 재사용성이에요
컴포넌트가 구조와 동작의 측면에서 완전한 구성을 이룰 수 있어야 해요
(스타일은 CSS의 변화로 바꿀 수 있어요)

그 전까지는 HTML, CSS, JS의 분리가 일반적이었어요
그러나 모바일 중심으로 가면서 트렌드가 컴포넌트로 바뀌어가고 있어요요

컴포넌트를 재사용하지 못하면 리액트를 쓰는 의미가 없어요

인자를 잘 활용하면 객체간의 결합도를 낮출 수 있어요
한 번 코딩하고 나서, 요구사항의 변화로 인해 수정이 적어질 수 있어요

function a(oFn) {
  if (true) oFn.afterBtn();
}
a({"afterBtn": aaa.ddd});

기능변화에 따른 변화를 줄일 수 있도록 결합도를 낮출 수 있도록 시도해보세요

객체 중심의 개발이 Event 중심의 개발과 이어져요

function a() {
  Dispatcher.emit("beforeFn");
  ele.on("click", () => {
    result = "ddddd";
    // 메시지 패싱
    Dispatcher.emit("afterClick", result);
  }
  Dispatcher.emit("afterFn", result);
}

aaa = {
  ddd : function(){}
}

a({"afterClick" : [aaa.ddd, fn2, fn3]});

무분별하게 프레임워크를 쓰는 것이냐 아니냐에 따라 실력이 확갈린다
어느 곳에나 리액트가 최선인 것이 아니다
필요한 사이즈에 적정한 도구만 딱 쓸 수 있는 것이 고급 개발자

Element 탭에서 Break on을 사용하면 변화를 만들어내는 코드를 알 수 있어요
Source 탭에서 async를 꼭 체크하고 보세요
옵션 커맨드 F를 누르면 소스 검색을 해줘요

develop branch를 만들어두고, 거기에 업데이트를 하다가 완성되면 master에 merge하세요

var dataObjFn = (function() {

   var json = ["aaaa"];

   function dataModelObj() {

   }

   dataModelObj.prototype = {
       getName : function() {
           return json;
       }
   }
 
   return dataModelObj;

})();

var dd = new dataObjFn();
누가 물어봐서.. 외부에서 인스턴스변수 접근을 하기 싫다고해서 .
알아서 보시길..
module pattern 의 일종.
접근이 되는 것과 되지 않는 것을 구분할 수 있어야 합니다
```

---

## 170320

```
동작이 된다 -> 개선을 한다 -> 내가 만든 구조로 다른 요구사항에 맞춰 만들어본다
객체별로 역할을 어떻게 나누는지 고민하는 것이 매우 중요해요
규모가 커지면 설계가 잘 된 것인지 여부가 바로 티가 납니다
특정한 요구사항으로부터 자유로울수록 좋은 설계입니다

옵저버 패턴, 구독 구현, 재개발

어떤 방법으로든 요소간 의존성을 낮출 수 있어야 합니다

전체적인 구조보다 사용자 입장에서 접근하는 것도 좋습니다다
그러면 직관적으로 쓰기 좋은 구성이 될 수 있을거에요
API를 만드는 느낌이죠, 인터페이스를 먼저 만들고 실제 구현을 그 다음에-

Controller는 View와 Model로 인해 생겨난 느낌이 강함
(View, Model의 변화에 따라 해야 할 일을 등록)

Dispatcher는 변화가 발생시 미리 가지고 있는 정보를 토대로 필요할 일을 실행시킴(register -> fire, emit)

옵저버 패턴이란 콜백함수를 제 3의 공간에 등록시켜둔 것이에요요

실행은 Dispatcher, View와 Model의 관계형성은 Controller
```

---

## 170321

```
학습하다가 진도가 밀리면, 계획을 미루세요
늦어도 좋으니 매일 아주 조금씩이라도 진보시키시면 됩니다

Git의 최소단위는 커밋
커밋은 최초 커밋 외에는 늘 부모가 있어요

브랜치도 결국에는 특정 커밋에 대한 참조일 뿐이에요
커밋 외에는 모두 참조변수에 불과해요

git pull = fetch + merge
fetch : 원격 저장소를 로컬 저장소에 반영
merge : 로컬 저장소에 있는 내용을 작업 디렉토리에 반영
checkout : 워킹 디렉토리를 특정 시점으로 바꿔주며, HEAD가 옮겨짐

echo $RANDOM >> 1.txt; git add .; git commit -m "2"

브랜치에 속해있는 것이 아니라, 지금 가리키고 있는 곳만 브랜치, 특정 커밋에서 git branch를 해보면 알 수 있음
head : 내가 작업하고 있는 커밋

한 번 저장된 커밋은 바뀌지 않아요, 원격에 반영한 커밋은 수정하지 마세요

git branch -f 3rd C4
3rd가 아닌 다른 브랜치에서 3rd 브랜치를 C4로 옮김

git checkout 3rd
git merge C8
3rd 브랜치를 C8과 merge

git branch -f 2rd C5
git merge C9

git checkout -b 4th

git clone jj tomasj
로컬 저장소 jj를 복사해서 tomasj를 만듬
로컬 저장소도 원격저장소가 될 수 있다

git config --global user.name "Hoyoung Jung"
git config user.name "Doraemong"

git config --global alias.co commit
git config --global alias.st status
git log --pretty=oneline --decorate --graph --all
git config --global alias.logs "log --oneline --decorate --graph --all"

alias gl='git logs'

git branch bb 6e20
git checkout -b 3rd 5aa7e62 : 5aa7e62에 3rd를 만들고 HEAD를 옮겨줌

^1 첫 번째 부모
^^1 할아버지
~1 부모
~2 할아버지
~3 증조 할아버지

git reset HEAD^
git rebase : 나를 들어서 상대편에게 얹어주는 것, 상대편이 베이스(머지는 내가 베이스)
rebase는 하고 나면 늘 한 줄이 되어요
나랑 base와의 차이점을 찾아서 쭉 얹어줘요
git rebase master : 나를 master 밑에 얹어줘요, 충돌날 가능성이 높아요

git checkout master
git merge 2nd

git branch -f master 2nd : force, master와 2nd를 merge

git cherry-pick : 커밋을 떼어와서 붙여요

git revert C2 : C3를 그대로 남겨두고 C2 상태로 돌려줘요
git reset --hard HEAD~2 : 할아버지로 돌려줘! 해당하는 커밋으로 돌아가!

리셋은 소프트 리셋과 하드 리셋이 있는데, 우리가 흔히 원하는 것은 하드 리셋이다(git reset --hard)

current branch는 -f 옵션을 사용할 수 없어요

옵션을 붙이면 전혀 다른 명령어가 되어요
git rebase -i HEAD~2 : 나와 HEAD~2과의 관계를 재정의(interactive)
- 커밋의 순서 변경
- 커밋 제거(엄밀히 말하면 해당 커밋이 없는 것을 새로 만들어주는 것)
여러 갈래로 퍼져있는 것은 편집할 수 없어요 HEAD~2 미만만 나와요
pick : 해당 커밋을 포함
reword : 커밋 메시지 변경
edit(amend) : 
squash : commit들을 합쳐서 한 커밋으로 만들어줌

git commit --amend : 바로 전 커밋에 추가 반영해서 새로 만듬

git remote add origin url
git push master origin
git push --set-upstream origin master
git push -u origin master

git rm --cached 4.txt : index에서 4.txt를 내려주셔요

git push origin master --force
```

![image](http://1.bp.blogspot.com/-ndhGl934uVg/VgV5SjuK0NI/AAAAAAAAAn4/BsSvs4KP_2E/s1600/git-vademecum.png)

```
1. HTML 레이아웃 구조 (쪼개고 쪼개고 쪼개고)
- 태그별 영역 확인 : * {outline: 1px solid; }
- 책의 목차를 생각해볼 것
2. 스타일
- reset.css (기본 margin, padding, line-style 등을 무위로 돌림)
- CSS 작성
- 필요시에 SASS 사용
```
---

## 170322

```javascript
name = "windooow";

var test = {
  getName: function(a, b, c) {
    console.log("abc ->", a, b, c);
    return this.name;
  }
}

var test2 = {
  name: "jinny",
  printName: function() {
    console.log(test.getName.call(this, 1, 2, 3));
    console.log(test.getName.apply(this, [1, 2, 3]));
    console.log(test.getName.apply(window, [1, 2, 3]));
  }
}

test.getName();
test2.printName();

var h = {
  name: "ooooo";
  log: function() {
    console.log(this.name);
  }
}

var o = {
  run: function() {
    console.log("run");
    document.querySelector("h1").addEventListener("click", h.log.bind(o));
  }
}

o.run();

// 콜백함수를 실행시켜주는 함수가 어떻게 실행되었는지에 따라 this가 결정된다
// bind: 선언할 때, 실행이 될 때의 컨텍스트 지정
// call, apply: 지금 실행시킬 때의 컨텍스트 지정
// 일단 짜고, 오류가 나면 디버깅을 하고, 그 다음에 바인딩을 해!

// Deactivate breakpoint라는 것도 있어요
// Breakpoints에서도 조정할 수 있어요
// XHR breakpoints에서도 조정 가능
```

---

## 170323 : MySQL 강의 수강

```
Lubuntu, MySQL 설치
왜 DBMS인가?
Data -> Information -> Knowledge -> Wisdom
Information에서 Knowledge와 Wisdom을 얻는 것이 빅데이터 분석의 목표

데이터 간의 관계를 이용하는 것것
SQL은 무엇을 할지 정의하는 선언적 언어

Not Only SQL, 관계형이 아닌 나머지 데이터베이스

CAP
- Consistency : 일관성, 데이터 저장
- Availability : 가용성, 얼마나 다운타임없이 운영되는가
- Partition Tolerence : 내성, 일부가 고장나더라도 전체는 유지됨

위 세 가지 모두를 만족하는 시스템은 구현할 수 없다

ACID
- Atomicity : 원자성, 트랜잭션을 할 때 All or Nothing 
- Consistency : 일관성, 삽입 갱신 삭제가 멀티유저를 상대로 바로 이루어지는가
- Isolation : 고립성, 마치 유저당 각각 하나의 데이터베이스를 사용하는 것처럼 고립성을 보장해주는가
- Durability : 내구성, 한 번 저장된 데이터는 영구적으로 저장되는가

수평 확장 : 서버 대수를 늘린다
수직 확장 : 사양을 늘린다
(수직확장이 좀 더 비용이 많이 듬)

SQL VS NoSQL
NoSQL은 CAP의 일부를 만족하기 위해 나오는 경우가 다수
ACID는 관계형 데이터베이스의 특징
관계형 데이터베이스의 Transaction 성질은 ACID로 요약가능

관계형 데이터베이스는 수직확장을 하는 경우가 다수
샤딩이라는 기술을 사용하면 수평확장도 가능
NoSQL은 수평확장이 쉬운 편

Graph DB (사이클 같은 것이 생기면 그래프)
Neo4j
- 복잡한 관계 처리 지원
- 친구 추천 알고리즘, SNS 등에 적합

순환 루프가 생기지 않으면, 하이라키가 있다면 트리

Document DB (JSON 기반으로 레코드 저장)
MongoDB
- json 기반 레코드 저장
- 아무거나 막 저장
- 비교적 빠르고 사용이 간단
- 조인에 부적합
- 이전 버전은 쓰기 성능이 좋지 않았음
- 서비스 구현에 가장 쉬운 DB

Key-Value DB (Key값으로 Value를 저장)
Redis, Mem-cached
- 엄청 빠르다
- 단순 데이터 처리
- 캐시 / 데이터 분산용

Cloud DB
Amazon DynamoDB, Google Firebase, Realm
- 설치 X, 사용이 쉽고 편리함, 고성능 고가용성 내구도

Hadoop Eco System
- HBASE, Spark

Cassandra : 대용량 처리
Elastic Search : 자연어 처리

--------------------

데이터 타입에 따라 저장 방식, 용량, 성능, 지원 가능 등이 달라진다
CREATE TABLE USER (
	USERID CHAR(12) PRIMARY KEY,
	NAME VARCHAR(64),
	MONEY DEC(12),
	SCORE INT
	CREATE_TIME DATETIME
);

MySQL Data Type
Numeric 숫자
Date, Time 날짜와 시간
String 문자열
Spatial 지리 데이터, 공간 데이터
JSON json 저장용

Numeric Types

| 타입 | 용도 | 기타 |
| --- | --- | --- |
| INT(=INTEGER) | 정수 | 4Byte |
| TINYINT, SMALLINT, BIGINT | 기타 정수 | 1Byte, 2Byte, 8Byte |
| DEC(10,2) | 8(정수) + 2(소수)자리 실수 | 정확한 계산용, Fixed Point |
| FLOAT, DOUBLE | 부동소수점 실수 | 4Byte, 8Byte, 약간의 계산오차가 있을 수 있음, Float Point, DOUBLE이 FLOAT에 비해 두 배 정확 |

SELECT * FROM A;
DELETE FROM A;
INSERT INTO A VALUES (1), (100), (1000);

숫자 타입의 범위를 초과하면 오버플로우되어 타입의 최대값을 저장

show warnings;

Date and Time Types
| 타입 | 용도 | 설명 |
| --- | --- | --- |
| TIME | 시간 | 1000~9999년 |
| DATETIME | 날짜와 시간 | 1970~2038년까지 저장 |
| DATE | 날짜 | --- |
| TIMESTAMP | 생성 및 변경시간을 자동 저장 | --- |
| YEAR | 년도 | --- |

timezone 등 여러 이슈가 많음

날짜 계산에는 DATE_SUB()와 DATE_ADD()함수를 사용
SELECT DATE_SUB(NOW(), INTERVAL 1 DAY); # 어제
SELECT DATE_ADD(NOW(), INTERVAL 1 DAY); # 내일
SELECT DATE_ADD('1999-12-31 23:50:00', INTERVAL 5 HOUR);

String Types

| 타입 | 용도 |
| --- | --- |
| CHAR | 고정길이 문자열 |
| VARCHAR | 가변길이 문자열 |
| BINARY | 2진 데이터 |
| BLOB | 대용량 데이터, 파일 등 아무거나 저장용 |
| TEXT | 대용량 텍스트, 인코딩 및 콜레이션 설정, 검색 가능 |

[콜레이션](http://chobodba.tistory.com/3)

select id, title, IF(completed, 'true', 'false') as completed from todo;

docker exec -it mysql mysql -u root

insert into user (email, name, pw) values ('crong@naver.com', 'crong', 'asdf');

select * from user
```

---

## 170328

```
git stash

CI, CD

Travis, Jenkins

back-end와 통신할 때, 최소한의 통신으로 처리할 수 있도록 노력해야 해요

회사가 아주 잘 풀려서 막 확장하려고 할 때가 매우 위험한 시기이기도 해요

MIT는 굉장히 자유로운 라이센스
GPL은 사용하면 소스를 반드시 공개해야 함

git commit에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다

vi에서 ~ 누르면 대문자로 바뀌어요

git push origin --delete serverfix

내가 Collaborators일 때, pull-request 순서
1. Master branch를 clone  
2. 새로운 브랜치를 생성
3. 브랜치 이름은 구현할 기능 이름으로 지정
4. add/commit/push
5. pull request 생성
6. Reviewer 지정
7. Reviewer는 Review 및 수정
8. 작업자가 다시 Commit 실행
9. 7번과 8번을 반복 후 merge

깃헙에 내가 만든 것은 모두 올리고, 자동으로 만들어진 것은 모두 올리지 마세요

서버 세팅 -> 소스 가져오기 -> 빌드 -> 실행

sudo apt-get install git vim-nox tmux

uname -a


Agile의 개념에 많은 부분은 도요타의 생산방식인 Lean방식에서 가져왔어요

Goal 수립 : 명확한 목표, Epic 정의
	- Story Workshop: Epic, Story 도출, 전략짜기, PBI(Product Backlog Items)
	- Breakdown : Epics -> Stories -> Tasks (Product Backlog -> Sprint Backlog)
Planning : 팀 전체의 계획, 역할분담
	- 이 일이 얼마나 걸릴지 추정하는 것이 가장 어려움
	- Planning Poker : 작업 크기 추정, 상호 연관 작업 간 조율, 담당자 결정정
	- 항상 애자일에서는 할 일들을 단위로 나누어서 시각화를 합니다, 팀 내 맥락이 공유되기 위함
	- Product Owner가 기능 명세서를 가지고 설명해준 뒤에 서로 얼마나 걸릴지 예상해서 생각한 근거를 나눔, 가용할 수 있는 시간 내에 가능한지를 검토하고 협의하는 과정
	- 이 과정에서 나오는 숫자들은 성과 측정과는 전혀 무관하다
Daily Scrum : 매일 서로 진행 상황/이슈 공유 + Blocker(장애물) 제거
	- 어제 무엇을 얼마나 했고, 오늘 무엇을 할 예정인데, 문제점/이슈는 이런 것이 있다
	- 내 상태를 다른 사람과 공유해서 확인하는 자리
	- 칸반보드에 현재 상황을 반영하고, 번다운 차트를 그려요(burndown chart)
	- 15분 내에 끝낸다
	- 저녁 때 해서 오늘 뭐했고, 내일 무엇을 할지를 나눌 수도 있어요
	- 이 모든 과정에서 성장을 위한 피드백을 주는 것이 목표에요
	- 해결책을 찾기 위해 공유를 하는 것이에요
	- 생산성을 떨어뜨리는 요소들을 발견하고 해결
	- Story별 Planning(스토리와 일정)
		- 단계별 목표를 주고 해결하도록 유도
		- Actor(주어, 사용자 || 관리자), Behavior, Goal(Why, Acceptance Criteria)
		- 추정 및 추정 기반 Planning
		- 이 Story가 테스트 단위 또는 데모 시연단위
		- AC가 곧 테스트커버리지 대상
Review & Retroperspective
	- 기획자의 의도와 개발자가 만들어낸 것이 같은가?
	- 서비스 배포를 통해 검증
	- Sprint Review & Retroperspective
		- 스프린트는 2주이고, 2주마다 계획한 그대로 잘 했는지 리뷰
		- 대부분 일정보다 늦게 끝나요요
		- 다 같이 더 잘 할 방법 찾기기
		- Speed Car Retroperspective
			- 장애요소를 찾아 다음 스프린트 때는 방해되지 않도록 제거
		- 2주 동안 할 수 있는 만큼만 해야지, 2주 후에 번아웃이 되선 안 된다다
		- 다 같이 전체적으로 잘 하는 것이 중요하지, 혼자 다 하는 것이 좋은 것이 아니다

핵심적인 기능을 많이 만드세요(로그인 기능만 만들다가 끝나는 프로젝트도 상당수)
기간 내에 할 수 있는 일을 잘 정리하는 것이 중요합니다
스크럼과 더불어 커밋 푸시도 루틴함이 필요해요
커밋이 Task와 같이 갈 수 있도록 시도해보세요
애자일은 더 잘 하기 위해서 만들어진 것입니다
리소스의 20~30%는 커뮤니티에 쏟게 됩니다, 이 점을 염두해두고 플래닝을 해야 합니다
생각보다 작게 잡고 예상을 해야 합니다
```

---

### 170329

```
브라우저별로 상황이 달라서, 로직만큼이나 브라우저를 위한 코드가 많아지게 됨
(예전에는 QuerySelector, InnerHTML, Insertadjacenthtml, classList, addEventListener와 같은 것이 없었어요)
그것을 대체하기 위해서 나온 해결책 중 하나가 jQuery
Method Chaining 즉, 직관적이고 사고와 일치하는 패턴으로 지원하기 시작함
API 설계가 참 잘 되어있고, 문서화도 참 잘 되어있음, 지원해주는 플러그인도 많음

요새는 갈수록 호환성 이슈가 줄고, ES표준이 좋아지고 있어서,
jQuery가 아닌 Polyfill을 쓰는 것이 더 좋아요
(jQuery보다 빠르고, 표준이니까 의존적일 필요도 없어요)
폴리필로 쓰다가, 지원 브라우저 버전이 업그레이드되면 폴리필만 걷어내면 되어요
Animation을 구현할 때, CSS3를 통해서 구현하는 것이 훨씬 좋아요
요새는 의존성이 없는 라이브러리를 선호하는 추세에요
jQuery Mobile이라는 것이 있는데, Mobile UI(+Interaction)를 만드는 패키지에요

체이닝을 지원한다는 것은 좋은 라이브러리의 요건이라고 생각해요
쓴다 안 쓴다는 일단 써보고 경험해보고 결정해보세요
장단점을 느끼고 누구에게 말할 수 있어야 하고 제작할 수 있어야 해요
이것을 써서 모든 것을 다 해야지 이런 식의 접근은 하지 말고,
좋은 도구라는 것은 무엇일지 고민해보세요
자바스크립트 표준이라는 것이 무엇인지 잘 이해하고 라이브러리에 접근해보세요
먼저 자바스크립트 표준에 대해 잘 이해해야 합니다, 표준을 나중에 익히면 표준이 어색하게 느껴집니다

회사에 가서 브라우저 지원 범위를 명확히 알아야 합니다, 그것에 맞춰서 최대한 표준을 활용해보세요

특정 디바이스에 따라서 애니메이션 등을 지원해주지 않는 방법도 있어요

javascript feature detection google search url
https://goo.gl/kL96fX

progressive enhancement google search url
https://goo.gl/j1Tk0c

jQuery Method 써봤냐고 물어보는 회사는 가지 마세요, 가봐야 후회합니다!

체이닝을 위해선 아래와 같이 구현되어야 해요

var obj = {
    append : function(name) {
        this.name += name;
		return this;
    },
    removeSpecial : function() {
        this.name = this.name.replace(/[^a-z]/ig, "");
		return this;
    },
    getName : function() {
        return this.name;
    }
}

var code = Object.create(obj);
code.name = "^^crong$$";
var cleanName = code.append("))))))").removeSpecial().getName();
console.log(cleanName); //crong

어떤 것은 상태값을 반환하고 어떤 것은 함수를 반환하는 등 일관성이 없어선 안 됩니다
사용자가 예상할 수 없게 만든다는 것은 설계가 잘못되었다는 것입니다
```

---

## 170330

```
컨벤션에 따라서 자바는 파일명과 클래스명은 대문자로 시작하고, 파일명과 public class명은 늘 같아야 한다

컴파일 : .java라는 파일을 컴퓨터가 인식할 수 있는 바이너리 코드로 바꿔주는 것

메인 메소드로부터 프로그램이 시작됩니다(entry point)

C언어를 쉽게 만들려고 나온 언어가 java에요(C언어 쉽게 + 객체지향)
C언어도 늘 main에서 시작해요, main이 없으면 실행되지 않아요
public 어떤 class의 main에서 무조건 시작!

자바는 함수를 메소드라고 불러요, 클래스 관점에서 바라보기 때문이에요
항상 소문자로 시작합니다

println : method
System : class
out : 객체

String[] : String의 배열타입을 인자로 주겠다

C#은 Java를 벤치마킹해서 만들었어요
Java 다음 언어는 Scala라고 보시면 되어요

public static void main

1byte
= 8bit
= 00000000 ~ 11111111
= 0 ~ 255

int 4byte = 4G
0이 8개있으면 1억이에요
int는 40억까지 되어요
범위 -20억 ~ +20억

float, double는 연산이 정확하지 않아요
java는 true false가 소문자에요

16진수 하나 4bit, 2^4 = 16 / 0000~1111
16진수중에 가장 의미있는 숫자는 64에요
16 * 6 + 4 = 100

2^4 = 16, 2^8 = 256

2^10 = 1K
2^20 = 1M
2^30 = 1G
2^40 = 4G

컴퓨터 내부에는 문자열이라는 타입은 없어요, 모두 숫자로 저장하지만 문자열로 보여주는 것 뿐이에요

String c = "hello";
c는 변수가 아니라 스트링의 인스턴스의 참조에요

메모리는 1byte씩 주소값을 가져요
0000 0000 ~ ffff ffff 이렇게 적으면 각각 4byte
a = 4
java외에는 케릭터와 스트링이 같아요

main() {
  int a = 4;
  double b = 3.5;
  String c = "Hello"
}

int a = 4;
int가 4byte이니, 0000 0000 ~ 0000 0003 에 4라고 적고 a라는 별명을 붙여줘요

double b = 3.5;
함수는 스택을 만들기 때문에, 주소도 위로 쌓여요(0000 0000 앞에 메모리 할당)

변수 선언은 각각의 타입에 맞는 메모리만큼 할당해주는 과정이에요

String a = "Hello";
스택이 아닌 heap에 저장되어요
4byte cccc 0000, Hello는 이런 주소에 저장되어요
c에 Hello가 있는 곳의 주소를 저장해요, primitive외에는 주소를 저장하는거에요

c = "Hello" + "World";
라고 하는 순간, "Hello World"를 어딘가 저장하고 c에 주소값을 할당해서 참조를 바꿔주는 거에요

나중에 "Hello"는 GC(Garbage Collector)가 정리해줘요

String a = "*";
for (1~1,000,000)
	a += "a";

String은 Imutable하기 때문에 돌릴 때마다 클래스를 하나씩 만들어줘요
String buffer는 Imutable하지 않아서 이럴 때는 String buffer를 써요
옛날 프로그램들은 GC가 정리해주지 않아서 Memory Leak으로 인해 뻗어요

C의 전제는 개발자는 올마이티하다 에요

다른 사람들이 잘 못 알아듣는 단어도 가끔 써줘야 해요
사실 리터럴은 누구나 아는 단어에요
변수에 값을 대입하기 위한 것
메모리(Data, Code, Stack, Heap)의 Code영역에 저장되고, 그것의 메모리주소가 변수에 할당되어요

한 줄일 때는 {}를 생략해도 되지만 무조건 쓰세요 (컨벤션을 위해서)

Tab과 Space는 절대 섞어쓰지마세요

for (i = 1; i > 10; i++) { 에서 i는 무조건 실행되어요
System.out.println(i); 하면 1이 나와요

코드는 짧은 것이 중요한게 아니라 가독성이 가장 중요해요

언어마다 구현방식도 철학도, 문법도 다 달라요
언어의 표준과 구현체도 달라요

// 메소드 선언 방식 public static returntype func_name(arg1, arg2) { }

자바는 함수가 무조건 클래스에 속해야만 합니다

method 안에만 code를 쓸 수 있습니다
java는 class method가 전부에요

void에는 return이 필요없어요

public은 접근제어자 이구용 !
static은 이 클래스를 객체화 시키지 않아도 바로 메모리에 올려놓겠다 라는 거에요
void는 각 메소드에는 항상 마지막에 return 이라는 반환값이 있어야 하는대, 그게 아무것도 없어도 된다 라는 거구요
main은 이 메소드는 이름이 main이다 라는 거 메소드 명
void자리에 int가 들어가면 이 메소드는 다 실행한 후 return 값으로 int값을 반환하겠다 라는 거에요

함수는 값을 돌려주겠다는 것과 종료하겠다는 의미를 같이 가지고 있어요

Object : State와 Behavior가 있는 소프트웨어 꾸러미
  - State : 변수
  - Behavior : 메소드 (함수)

Class : user defined data type with behavior
  - new 키워드를 이용함

Class는 new가 필요한데, String은 없어도 되어요
모든 클래스는 멤버변수를 가질 수 있어요, 각각의 인스턴스들이 고유하게 가지는 값을 Instanc 변수라고 해요

DB에 저장되는 것들이 Class의 대상이 되어요

같은 folder에 있는 class file들끼리는 바로 불러와서 쓸 수 있어요

포유류라는 것은 원래 존재하지 않죠? 이런 것으로 추상 클래스라고 있어요
추상 클래스는 행동이 없어요, 동작이 없는 메소드가 추상 메소드, 추상 메소드가 있으면 추상 클래스
구현된 몸체가 없으면 추상 메소드
추상 메소드가 있으면 객체를 만들어낼 수 없어요, 상속받을 다른 클래스를 만들고 추상 메소드를 대신 정의해줘야 해요(메소드 오버라이딩)
move는 다 하고 싶지만, 각각의 방식은 모두 다르게 하고 싶을 때

다중상속을 위해 인터페이스라는 것이 있어요!
인터페이스는 능력에 관한 것이 많아서 able로 끝나는 것이 많아요
인터페이스에는 구현된 것이 아무 것도 없어요!
추상메소드만 있으면 인터페이스에요

면접장에서 Java가 다중상속이 지원되는지 를 자주 물어봐요

new로 만드는 순간 무조건 Heap에 저장되어요

메모리를 잘못 썼기에 NullPointerException이 발생해요

추상 메소드 -> 추상 클래스 -> for 다중상속 인터페이스
배열 선언시의 new

잘 모르겠을 때는 그림을 그려봐라

CPU 클락은 1초에 컴퓨터가 몇 개의 명령어를 처리할 수 있는가를 나타내는 단위

시간의 최소단위가 클락이라고 해서, 모든 명령어를 저 단위로 할 수 있다는 것을 의미하지 않음
어떤 명령어는 1클락, 어떤 명령어는 1000클락
나누기는 정말 오래 걸리는 연산이에요, 정수보다 실수를 연산하는 것이 훨씬 느려요

기계어 -> 디스크 -> 실행 -> 메모리

Program Counter : 내 프로그램이 어디까지 실행되었는지 기록하는 레지스터

컴퓨터 구조 라는 수업을 들으면 컴퓨터 구조에 대해 알 수 있어요

메모리와 레지스터 사이에 캐시가 있어요

프로그램이 메모리에 올라가면 프로세스가 됩니다
프로세스는 실행중인 프로그램이에요

32bit machine은 명령어를 한 번에 읽어들일 수 있는 것이 4byte이에요
한 번에 전선 32가닥을 읽어들일 수 있다는 것이에요요
프로세스 하나당 4GB를 차지해요
메모리의 일부를 하드에 저장했다가 필요할 때 불러오는 것은 swap방식이에요
4Gbyte를 모두 쓸 수 있지만, 일반적으로 그 중의 일부만 사용해요
가상 메모리 덕분에 동시에 많은 것을 처리할 수 있어요
프로세스는 가상 메모리를 쓰지만, 실제로 어느 물리 메모리에 저장되는지는 알지 못 해요
모든 프로세스는 4GB를 혼자 쓴다고 생각하고 있어요
용량이 늘어나면 swap이 덜 일어나요

메모리는
CODE : 컴파일된 기계명령어를 보관하는 곳곳
DATA : 전역변수
STACK : 지역 변수, CallStack (함수 호출이 끝나면 사라져요)
HEAP : 동적 할당영역(JS의 Object를 만들면 HEAP에 들어가요)

GC는 HEAP을 잘 정리하는 것이에요
STACK은 함수가 끝나면 알아서 다 휘발되어요
```

---

## 170331

```
비주얼디자인에 너무 초점을 두지 둘 필요가 없고, 외부 스타일 가이드를 가져다 쓸 것
데모 때 이쁘게 보이는 것은 아주 중요합니다, 경영진은 주로 UI로 평가하곤 합니다

완료조건대로 테스트를 하고, 데모 시연을 하세요
모든 팀원이 이번 주 해야 할 목표를 정확히 알고 있어야 합니다
데모 때는 이번 스프린트에서 완성되어야 할 내용이 담긴 데모 시나리오를 가지고, 보면서 진행하면 됩니다

데모를 하려면 전 날 자정 정도까지는 코드 프리징이 되어야 하고, 그러기 위해서 그 이전의 테스트 계획 등도 착착 나와야 합니다
데모도 하나의 릴리즈입니다, 이번 주의 완성품은 어디까지 되어야 하는가?

이슈에 커밋번호를 넣어놓으면 바로 연결할 수 있어요
하나의 이슈가 해당하는 어떤 커밋과 연결되어있는 것이 아주 좋아요
이슈에 대한 이슈를 기재하세요
리스크를 최소화하기 위해서 수시로 머지를 해서 지속적 통합(충돌없이 계속 빌드/배포를 할 수 있는 것)을 하세요

Issue를 Close할 때, 그 시점에 대한 이슈들을 적어주는게 좋아요(안 그러면 추정을 할 수가 없어요)

원래 Ajax는 다른 도메인에는 안 되요
그래서 최근에 CORS라는 것이 나왔어요
서버에서 헤더값에 관련한 설정을 할 수 있어요, 내가 허용할 수 있는 도메인이 무엇인가, 일치하면 데이터를 받을 수 있어요

JSONP (padding)은 완전 다른 방법이에요, 콜백함수를 주고 받으며 클라이언트에서 실행하는 등의 방식이에요
네이버 검색창은 JSONP로 되어있어요, 사실상 표준처럼 제일 많이 사용해요

기획서는 쉽게 공유/수정할 수 있는 방법이 가장 좋아요
업무할 때 가장 비효율인 것중 하나가 싱크가 제대로 안 되는 것이에요

커밋을 좀 더 자주 나누어서 많이 하세요, 전체적으로 더 자주 하셔야 합니다

팀 활동을 최대한 많이 해보세요
페어 프로그래밍도 꼭 해보세요
```

---

### 170405

```
ES6는 아직 한국은 많이 못 쓰이고 있어요, 하지만 외국에서는 많이 쓰이고 있고, 이게 곧 표준이기 때문에 잘 배워야 해요, 브라우저 호환성이 매우 좋아졌어요

Const를 기본으로 쓰고, 문제가 생기면 let을 쓰세요, var를 쓰지마셔요

새로운 메소드를 익힐 때 브라우저 지원범위를 늘 보셔야 해요

for in은 객체를 돌릴 때 써요
자기가 가지고 있지 않은 것도 함께 탐색해요
사용자에 의해 추가된 프로퍼티를 다 가져와서 보여줘요
자기 것이 아니어도 가져와요
객체에서 쓸 때도 내가 가지고 있는 것만 보여주려면 hasOwnProperty를 썼어야 했어요

for of는 자기가 가지고 있는 것만 보여줘요
string에서도 쓸 수 있어요

concat처럼 Spread Operator로도 객체를 복사할 수 있어요

=== 원시타입일 때는 값으로 비교, Object일 때는 주소값으로 비교

...을 외우려고 하지 말고, 펼쳐서 들어간다고 생각하면 아주 쉬워요

원래 문제가 무엇이었는지 잘 익히고 배우는게 중요해요

Destructuring을 쓸 때,
배열은 순서가 중요하니까 ,,로 명시가 필요하고
객체는 이름이 중요하니까 property name을 명시하면 됩니다

function getNewsList({target}) {
  console.log(target);
}
getNewsList(evt);

자기가 아는 지식을 설명할 줄 알아야 합니다

객체에 관해 조작할 때는 set보다는 weakSet을 사용하세요
데이터가 담겨있는지 체크해야 한다면 set, weakSet을 떠올려보세요
새로운 데이터 구조에요
문자열은 set으로 쓰세요

set을 Array.from을 쓰면 변환할 수 있을거에요

map, weakMap은 키/값 구조에요(set보다 부연설명을 할 수 있어요)
예를 들면 함수를 호출회수를 담아놓을 수 있어요
map은 set에 대한 보완이에요, 있는지 없는지만 체크 set, 부연설명 필요하면 map
참조를 가진 것만 모으고 싶으면 weakSet, weakMap

Class를 통해서 set과 map을 구현해보세요

여기서의 Map과 고차함수의 Map은 다른 뉘앙스이다

면접 때 질문을 받았는데 설명을 못 하겠으면, 이해했었는데 잊어버려서 5분 시간을 주시면 찾아보고 설명드리겠다고 해볼 것

tagged 할 때 \ 붙여주면 문자열로 쓸 수 있어요

arrow function을 쓸 때 {}를 안 쓰면 자동으로 return을 해줘요

var obj = {
	run() {
		setTimeout(function() {
			console.log(this);
		}, 1000);
	}
}
obj.run(); //window

var obj = {
	run() {
		setTimeout(() => {
			console.log(this);
		}, 1000);
	}
}
obj.run(); //obj

Debugger를 계속 하면서 추적하고 탐구하는 습관을 들이세요

비동기 콜백 상황 : Ajax, EventListen, SetTimeOut

존재에는 모두 이유가 있습니다

Default Parameter 대체하기
function sum(value, count, size) {
	count = count || 10;
	size = size || 20;
	return value * size;
}
sum(3,10);

rest operator와 spread operator는 다릅니다

array.every, array.some

Object.create가 사실상 표준이라고 생각하면 되어요!

__proto__가 표준이 되었어요!

항상 가볍게 짜는 것이 좋기 때문에, 라이브러리에 의존하지 않고 순수한 코드로 구성하는 것이 좋습니다

DOM과 Template를 최적화시키는 것이 프론트의 핵심이에요
모바일은 ES6를 쓸 수 있습니다
ES6는 Babel로 트랜스파일링을 할 수 있기 때문에 괜찮지만,
IE8, 9는 ES5도 지원하지 않아서 PC는 어려움이 많습니다

```

---

### 170407

크롱의 조언
```
커밋단위가 너무 큼
작은 기능이 완성되었을 때 하라
정말 작아도 좋다
라인 수와 상관없이, 함수 단위가 좋다

자주 올리는 것이 훨씬 낫다

팀으로 같이 문제를 해결하는 것이 중요한데,
각자가 맡은 부분에 너무 집중한 것이 아닌가?

브랜치명도 중요합니다

마일스톤을 좀 더 쪼개보세요

이슈에 세부 작업을 표시해서 진행해보세요

커밋로그를 잘 써보세요

항상 머지를 자주 해주세요요

테스트 코드를 통해서 머지할 때 검증되도록 하는 것이 좋습니다

Merge & Change 라는 항목을 프로젝트에 따로 만들어두는 것이 정말 좋아요

팀의 대시보드, 현황판 역할을 프로젝트가 해줘야 해요
https://github.com/NamNUNU/SNS_Project/projects/2
극찬대상

완료조건이 충족되었는지 여부는 커밋 아이디를 적어두어서 확인할 수 있도록 할 것

팀의 코드라면 서로 리뷰를 하고, 최대한 코드를 공유할 수 있도록 노력하고 하는 것

1년에서 실제 개발 기간은 3개월 정도 밖에 안 되곤 해요,
커뮤니케이션, 테스트, 버그 대응 등 하다보면 개발할 시간이 별로 없는 것이 현실입니다

테스트에 신경쓰면 한 단계 높은 개발자가 될 수 있을 것입니다

팀의 상태를 자주 들여다봐야 합니다
마음 속으로 대충 알고 있는데, 그것을 꺼내놓는 용기를 가져야 합니다
거듭 진단해보세요

CSS 단위를 통일시키세요
컨벤션을 만들어서 유지하세요
클래스명은 어떻게 쓸 것인지도

유틸리티와 같은 것은 별도 파일로 독립시켜서 가져다쓰세요

고차함수도 한 번 써보세요

자주 쓰이는 것은 변수로 캐싱하세요

하드코딩하지 마세요
이름을 적는 순간 그곳에 종속된 메소드가 되어버려요

외부 오픈소스를 썼다면 README.md에 기재해주세요

라이센스에 대해서도 공부해보세요

외부 라이브러리를 쓸 때는 별도의 파일로 만들어놓고 불러다 쓰세요

Util을 만들어두면 js.doc와 같은 라이브러리를 통해 함수인자, 리턴값 등을 적어서 쓸 수 있게 공유해야 해요

지역변수로 쓸 수 있는 것은 지역변수로 쓰세요

EventListenr 안에는 밖에서 만들어둔 것을 호출해서 쓰세요

템플릿을 관리할 때는 일관된 방식을 쓰는 것이 좋아요
기왕이면 HTML안에 적는 방식은 피하세요

잘한 것, 못한 것, 개개인에 대한 솔직한 피드백

커밋 하나 하나를 쳐다볼 것이지, 기능 많이 구현한 것은 별 필요없을 수 있어요

조금씩 아는 것은 다 모르는 것이나 별 차이 없어요
```

---

## 170410

```
실제 조에 개발 인력이 절반이 안 될 수 있어요

분업을 할지 협업을 할지 결정하는게 좋아요

클라이언트는 원래 모델을 전혀 신경쓰지 않았는데, 그것을 가져오기 시작했어요
View만 있다가 Model이 오니까 Controller가 따라왔어요, 그러다보니 복잡도가 증가해요

React는 View가 핵심이에요

OpenGL을 Web에서 쓸 수 있게 해준 것이 WebGL이에요

라이브러리는 개발단계에서 자주 사용되는 기능들을 묶어서 제공해요

프레임워크는 모두 묶여서 패키지로 제공되어요
프레임워크는 구현해야 할 기능들이 내부적으로 모두 연결되어있고 관계되어있어요
정해져있는 틀(와꾸)이 있어요, 러닝커브가 높아요
대신 숙련되지 않은 개발자들도 평균 수준을 유지할 수 있어요
협업에도 유리해요

규모가 큰 회사들은 자체적인 프레임워크를 도입하려는 경우가 많아요
프레임워크를 아예 안 쓰는 경우들도 있어요, 사실 Vanila가 제일 빨라요

자바 개발자들은 앵귤러를 선호하는 경우가 많아요(원래 하던 개발과 유사해요)

리액트는 가벼운 프레임워크 또는 라이브러리와 프레임워크의 중간이라고 생각해요

프레임워크에 대한 사고가 있어야 해요

SPA : 페이지 전환없이 이루어지는 서비스
구글 닥스, 페이스북, 트렐로

SPA가 목적이어야 하는 것은 아닙니다

인터넷은 리소스라는 키워드가 중요해요
앱과 다르게 인터넷은 공유를 할 수 있어야 합니다
그러기 위해 리소스는 유니크해야 합니다
웹으로서의 큰 장점은 공유에요

SPA는 페이지가 바뀌지 않지만 가짜 URL을 만들어서 보여줘요
SPA에서는 템플릿이 매우 중요해요, 템플릿 작업 자체가 많아져요
Ajax로 서버랑 데이터를 주고 받으면서 DOM조작이 빈번하게 일어나는 등의 진행이 이루어졌어요
SPA가 성공하려면, 클라이언트만 잘 한다고 되는 것이 아니에요
맨 처음 로딩 때는 서버사이드 렌더링을 하고, 그 다음부터는 API 설계를 잘 해서 효과적으로 통신을 주고 받는 등의 협업 과정이 필요해요

프레임워크의 단점을 얘기할 수 있는 사람은 정말 깊이 써본 사람일거에요
공식 홈페이지에는 약파는 내용이 워낙 많아요

라이브러리: 기능의 재사용
프레임워크: 설계의 재사용

프레임워크를 도입하려면 초기 도입을 위해 리서치 시간이 많이 필요해요
우리 서비스에 잘 맞는 설계를 하는 것이 유지보수를 위한 비용을 훨씬 절감시킬 수 있어요
React, Vue, FrameWork X 들을 모두 프로토타이핑해보는 등의 과정을 거쳐요
우리 팀이 원하는 서비스를 해당 프레임워크로 구현할 수 있는 능력(여건)이 있는지 확인할 수 있어요
팀 내에 비협조적인 인간이 있다면 내보내야해요
리서치하는 능력도 매우 중요해요, 보편적인 자료만으로는 우리 서비스에 잘 맞는지 검증하기 어려워요
이미 공개되어있는 자료를 공유하는 것은 별 의미가 없어요

UI는 재사용이 매우 어렵다는 것이 팩트에요

컴포넌트 단위 개발은 내부에 HTML, CSS, JS 모두 내포하고 있어요 (재사용을 위해서)
인터랙션과 스타일이 같아야 재사용할 수 있으니, 구글은 매테리얼 디자인 같은 것으로 통일시켜야 해요
폴리머를 쓰려면, 스타일이 통일되어있어야 해요
디자인과 스타일이 동일하기에 레고처럼 획일적으로 딱딱 쓸 수 있어요
한국 사이트들은 복잡하고 헤비하고 밀도있게 가기 때문에 부적합한 면도 있어요
또한 리액트는 퍼블리셔와의 협업 과정이 어렵기 때문에 부적합한 면도 있어요
우리나라는 R&R이 쓸데없이 명확해요, 네이버는 nts가 모든 마크업을 다 하고 있는데, 리액트를 쓰는 일부 조직은 자체적으로 해결하는 것이에요
혼자 마크업과 JS를 다 하는 환경에 굉장히 적합해요, 프론트엔드 개발자가 구조 스타일 동작을 모두 다 할 수 있어야 해요, CSS도 못 하면 풀스택을 떠나서 클라이언트 풀스택조차 못 하는거에요
퍼블리셔를 거쳐야만 한다면 필연적으로 개발이 늦어질 수 밖에 없어요

모바일 웹은 PC 웹에 비해 보다 단순하기에 리액트와 같은 것이 더 적합할 수 있어요
우리나라는 인터넷이 매우 빨라서 성능&최적화에 대한 이슈가 흘러지나갔어요
대신 글로벌하게 가는 사이트들은 여전히 많은 공부가 필요해요

논리적이지 않은 것은 굳이 외우려고 하지 마시고 디버깅으로 해결하세요

console.log(a); // function a() { console.log("a"); }
var a = 1;
function a() { console.log("a"); }
console.log(a); // 1
a(); // a is not a function

리액트는 다른 프레임워크들과 다르게 뷰에만 집중했어요(모델 빼!)
컴포넌트, JSX, Virtual DOM
Virtual DOM이 왠만한 코드보다는 빨라요,
내가 최적화에 대한 방법을 아주 잘 알고 있다면 비슷한 퍼포먼스일거에요
마법처럼 동작하는 것은 성능적으로 의심해봐야 해요
직접적으로 비교를 해보세요

성능 차이가 있더라도, 유저가 느끼는 차이(체감 속도)가 훨씬 중요합니다
성능 차이로 프레임워크를 선택하는 것은 부적절해요
개발 생산성이 중요해요

리액트 코드가 간결해보이는 것은 ES6의 힘인 것이 커요, 리액트 덕분이 아니에요
모든 프레임워크들은 당시의 첨단 기능들을 넣어서 멋있어보이려고 해요

ES2015라는 표준은 2015년에 따단하고 나온 것은 아니고, 미리 나뉘어 보급되고 있었어요

리액트가 가져다 쓸 함수들이 많아서 라이브러리와 같은 특성이 있어요

module loader와 같은 기능들이 아직 대부분의 브라우저에서는 동작하지 않는데,
webpack과 같은 도구를 사용해서 사용할 수 있어요

공식홈페이지에 있는 자료들을 바탕으로 공부를 하고, 해당 내용으로 Q&A를 하는 것이 참 좋아요요

한글 콘텐츠를 소비하다보면 영어에 대한 거부감이 점차 커져요
영어로 읽는 트레이닝이 1~2년 되면 금방 해결되어요

프레임워크를 책으로 공부하는 것은 바보같은 행위에요
안 바뀌는 책을 사서 공부하세요
프레임워크는 어제 발매된 것을 기준으로 개발하는 것이 최선일거에요

react는 this.state에 상태와 관련한 정보를 담아두고 그것이 바뀌면 렌더링을 다시 해줘요

createElement 또는 JSX 중에 선택해서 사용할 수 있지만 가독성이 JSX가 더 좋아요

Webpack은 loader와 plugin을 공부해야 함
code syntax, 코드에서 쓰는 여러 가지 신택스 결과물들을 가져다 쓸 수 있도록 해주는 것, 간편하게 외부 파일을 가져와서 코드에 포함시켜줌, loader
코드 최적화, 코드 검사 등은 plugin

lint 코드를 정적으로 검사, 로직이나 시맨틱하지 않은 부분

gulp, grunt, Yeoman 등은 webpack으로 평정되어가는 분위기에요

react component를 담은 파일은 .jsx라고 하면 명시적이어서 좋은 것 같아요(view만 담당하는 파일)
action code는 .js가 맞아요

새로운 프레임워크를 만나면 일단 구글에서 best practice를 붙여서 찾아봐요(원작자의 코드면 베스트)

프레임워크로 짜도 의외로 사람마다 굉장히 달라요, 그래서 잘 짜는 사람의 코드를 봐야 해요

코어는 가벼운데, 살을 붙이다보면 커지게 되어요

전반적인 추세는 경험이 없다면 앵귤러, 자바스크립트를 잘 하면 리액트(조립을 할 수 있는 경우)

구글은 만들어놓고 안 써서 믿을 수가 없어요(앵귤러, 폴리머 등)

새로운 것 나왔다 -> 왜 나왔지? 서포터가 있나? 누가 쓰나? 의심 의심 의심

render 안에서는 보여주는 것들을 담아두시고, for, if 등의 작업은 별도 메소드에서 해보세요
render에는 로직을 넣지 마세요

state나 lifecycle이 없다면 functional component로 짜는 것이 더 좋아요

리액트는 그냥 카멜표기법
```

---

## 170412

```
트렌드에 너무 예민해하실 필요는 없어요

이해하지 못 하고 사용해선 안 되어요(원리, 필요성 등)
(axios를 왜 사용해야 하는가? ajax로는 왜 안 되는가? ajax와의 차이가 무엇인가? 어떻게 구현했을까?)

키 값에는 고유한 값을 넣어줄 수 있으면 좋아요

CSS를 inline으로 하기 보다는 ClassName으로 컨트롤을 많이 합니다

defaultProps는 property값이 없으면 세팅해줄 때 적용되는거에요

bind는 contructor에서 하는 것을 권장해요

promise를 적용한 ajax인 fetch라는 것이 있어요

setState는 DidMount 이후에 실행되어요
setState도 비동기에요
WillMount에서 setState를 사용하는 것은 이상한 것이에요
(아직 그리지 않았는데, 그 사이에 변경사항을 주는)

DOM조작은 DidMount에서 해야 해요

React는 View에만 집중하도록 하는 것이 맞아요(Model, Hanlder를 분리하세요)

shouldComponent를 통해서 변경되어도 렌더링되지 않도록 할 수 있어요(성능 개선)

Ajax를 주고 받아서 보여주려고 하면, 비동기적으로 데이터가 없는 모습을 보여주는 상황들이 발생할 수 있어서 해결하기 위한 여러 가지 방법이 있어요
React를 Server에서도 사용할 수 있어요, 서버사이드 렌더링

create-react-app를 활용하면 Webpack 세팅을 별도로 하지 않아도 되어요

그저 가져다쓰지 말고, redux와 같은 것을 설계해서 사용해보세요
(redux와의 기술적 차이, 내 것의 장단점, 한계, 철학)

Redux는 Architecture에요
React와 Redux는 전혀 다른거에요
Redux는 그저 데이터를 관리하기 위한 패턴이에요

데이터, 스토어, 스테이츠, 모델 이라는 표현 중에서 states와 store를 많이 사용합니다
서비스가 커도, Store는 하나입니다(하나의 객체 안에 모든 데이터를 JSON과 같이 보관하고 있는 것)
코드 상으로는 Store가 보이지 않고, 내부 코드에서 구현되어있어요

처리의 단순화를 위해서 단방향 흐름으로 처리해요
프레임워크에서는 이러한 디자인 패턴이 매우 중요해요
어떻게 흘러가는지 예측이 가능해진다, 소프트웨어는 예측가능한지 여부가 매우 중요합니다

Action이 호출되면, 무엇이 발생했는지 Dispatcher에게 알려주고, 그것을 Store에 전달해주면 상태값을 변경하고,
그 변경된 상태값을 View에 전달해서 어떤 View가 바뀌었는지 확인하고, 다시 렌더링한다
Action(발생했다) -> Dispatcher(전달자, 등록된 것을 실행) -> Store(모델 변경) -> View(뷰 변경)
? Action은 EventListener와 정확히 동일한가

Reducer가 Store 내부에 있어요
Action에 따라 Reducer를 여러 가지로 나눈다
Reducer는 상태값을 바꾸는 함수에요(분기문 처리)

Store는 해당 결과를 취합해서 저장하고 있음
Store는 Class
Store를 최상위 컴포넌트에 전달해주고, props로 내려보내면서 활용
(Store가 직접 Component를 부르지는 않는다)
Store는 자기가 바뀌었을 때 View 어디가 바뀌어야 하는지 전혀 모른다, 의존성이 없다

Store가 바뀌었을 때 View를 어떻게 바꿔줘야 하는지를 정의하는 과정이 매우 복잡해요
이 부분이 Redux의 핵심이에요

Dispatch가 Store에 있는 Method에요

실제로는 View에서 Dispatcher를 호출하면서 Action을 넘겨줘요
View에서는 직접 데이터를 변경하지 않고 Action을 Dispatch로 전달해줘야 해요

여태 수업하면서 이해하지 못 하고 있는 부분
1. dispatcher
2. CSS
3. React practical
4. Honux 전체

Action은 개발자가 함수로 정의해줘야 해요
그리고 View에서는 해당 함수를 호출해요
Dispatch는 Object 형태의 인자를 받아요
변경시키고 Store가 그것을 모아서 View에 전달해주고 렌더링한다

좋다고 그냥 쓰는 것이 아니라, 원론적인 고민을 해야 해요
늘 의심해야 해요
Redux는 복잡한 어플리케이션을 개발하기 위해 협업해야 하는 상황에 적합해요
Redux를 사용하기로 했으면 엄격하게 일관되도록 사용해야 해요
Component, function name, Action, Reducer, Coding Convention, Test, Comment, import 등

? 왜 Dispatcher를 사용하면 결합도가 낮아지는가? 같은 로직이 스텝이 늘어나 더 복잡해진 느낌

Action은 무엇을 해야 할지, Reducer는 데이터를 변화시킨 후 바뀐값을 리턴
결국 최종목적은 View를 바꾸는 것입니다
Observer Pattern + Messaging Pattern

디자인 패턴은 개발을 하면서 학습을 해야 합니다, 그래야 내 것이 되고 아키텍쳐로 성장할 수 있어요
Store라는 namespace가 있고, 그 안에 Reducer 여러 개가 담겨있는 셈이에요

Action은 객체 형태로 무엇을 해야 할지 반환하는 함수
Reducer는 데이터에 변화를 준 후 변경된 데이터를 반환해주는 함수
Store안에는 여러 가지가 혼재되어있어요
action을 reducer에게 전달해주는 것은 dispatch, subscribe는 State변화시 Callback 실행, getState는 subscribe안에 담아두어 Store에 저장된 데이터를 반환하도록 할 수 있다

min된 것은 error message 등을 보여주는 코드가 다 날려버린 것이므로 production용으로만 적합합니다

major 이전 버전과의 호환성을 보장하지 않음(함부로 업그레이드하기엔 위험성이 큼)
minor 이전 버전과의 호환성을 보장

trivial ?

액션은 보통 대문자로 정의해요
dispatch는 자기가 어디로 전달해야 할지 알아야 하기 때문에 store에 대한 정보도 전달받아야 해요

redux와 비동기가 많이 어려워요

어떠한 패턴을 언제 써야 하는지, 언제 쓰지 말아야 하는지
쓰는 것은 패턴이 허용하는 유용성에 해당할 때여야 한다

객체 찾기
객체 크기
인터페이스
구현
재사용
런타임/컴파일타임
변화에 대비
```

```javascript
class ShowLog extends React.Component {
  constructor(props) { // 왜 쓰지?
    super(); // 왜 쓰지?
  }
  
  render() {
    let showHTML = null; 
     if(this.props.showLog) { 
        showHTML = (<div>{this.props.currentNumber} 번째 li가 선택됐어요!!!
                      <p><button onClick={this.props.onClick}>닫기</button></p>
                   </div>);
                      // 왜 ()로 감싸주었는가?
     } else {
        showHTML = (<div></div>);
     }
                    
    return (
      <div>
        {showHTML}
      </div>
    )
  }
}


class BlogList extends React.Component {
  
  constructor(props) {
    super();
    this.clickHandler = this.clickHandler.bind(this); // 왜 해줘야 하는가? 앞 this와 뒷 this는 왜 다른가? this가 이 클래스 내에서 언제 바뀔 수 있는가?
  }
  
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.posts !== this.props.posts; // props의 scope는 이 클래스 전체?
  }
  
  clickHandler(i) {
    this.props.onClick(i); // posts는 property, onClick은 method?
  }
  
  // container Component의 Constructor와 render 사이에 들어갈 코드들의 종류

  render() { // render 함수의 정확한 정의
    console.log("bloglist redner..");
    const posts = this.props.posts;
    const listHTML = posts.map((v,i) => { // 왜 배열을 돌려받는 것이 목표가 아닌데, forEach를 쓰지 않는가? => 현재 li 배열을 만드는 것이 목표, forEach는 단순 순회만 할 뿐 아무런 return을 만들어내지 못한다
      return (<li
            onClick={ e => this.clickHandler(i)} // onClick은 약속된 이벤트 리스너 함수인가? => 그렇다, https://facebook.github.io/react/docs/events.html#supported-events
            key={i}> // key 또한 약속된 키워드인가? => 렌더링을 최소화하기 위해 unique index
              {v.title} 
            </li>)
      });    
    
    return(
      <ul>
        {listHTML}
      </ul>
    )
    
  }
}

class MyBlog extends React.Component {
  constructor() {
    super();
    this.state = {posts : [ // 왜 state인가? state는 언제 사용하는가? => Component 안에서 사용할 데이터, 향후 state 관리는 redux에게 넘기게 됨
      {
        "title": "sunt aut facere repellat",
         "body": "quia et suscipit\nsuscipit"
      },
      {
        "title": "qui est essexxxxx",
        "body": "est rerum tempore vitae\nsequi sint"
      }
    ], 
    showLog :false,
    selectedNumber : 0,              
    };
  }
  
  listClickHandler(number) {
    number++;
    this.setState({'showLog':true, 'selectedNumber':number});
    // setState를 호출하면 this.state를 찾아서 변환해준다
  }
  
  closeLayer = () => {
    this.setState({'showLog' : false});
  }

  render() {    
    return (
      <div>
        <h2>My Blog posts :-)</h2>
        <BlogList onClick={this.listClickHandler.bind(this)} posts={this.state.posts} />
        <ShowLog 
          onClick={this.closeLayer} // this.state. 이 아닌 this. 는 props를 뜻하는가? constructor 와 render 사이에 선언한 함수에 대해서만 이렇게 하는가?
          currentNumber={this.state.selectedNumber} 
          showLog={this.state.showLog}
        />
      </div>
    )
  }
}

ReactDOM.render(
  <MyBlog/>, document.querySelector("#wrap")
);
```

---

### 170413

```
Amazon sofa 를 참고해보세요

예전에는 SE 혼자서 100대도 관리하기 어려웠는데, 요새는 8,000대도 관리할 수 있어요
또한 서버를 하나 새로 만들려면 2주 ~ 2달 걸렸는데, 이제는 2분이면 할 수 있어요
서버에 문제가 생기면 그냥 꺼버리고 새로 만들면 되어요
쓰고 나서 더이상 필요없으면 쉽게 정리할 수 있어요

5~7년을 바라보면서 투자하는 회사에요
아마존은 세상에 존재하는 모든 것을 팔아보려고 하는 집단이에요
Cloud라는 단어가 없던 시절에 Amazon Web Service를 만들고 7년 동안 적자가 났어요
3년 전부터 흑자로 돌아서면서 주가가 몇 배로 뛰었어요
AWS Cloud 10조를 한 해동안 팔았고 수익률이 25%에요

아마존의 문화를 쿠팡이 카피한다고 해서 쉽게 되진 않아요
문화가 아닌 그 중 일부인 정책을 카피해왔기 때문이에요
일은 삼성전자가 많지만, 아마존은 일을 할 때 자기가 자기 스스로 생각을 하고 윗사람이 일을 더 많이 하는 구조에요
아마존은 일을 덜어내고 덜어내면서 점차 아래로 내려주는 방식으로 일을 진행하는데,
삼성전자는 밑으로 내려갈수록 업무가 눈덩이처럼 불어나고 윗 사람이 모든 일을 하는 것으로 포장되어요
아마존은 돈을 벌기 위해 태어난 회사에요
1년 안에 90% 이상 다 나가지만 회사가 잘 돌아가요

드랍박스에서 대부분의 고객들이 1TB를 빌려도 50MB도 쓰지 않아요
드랍박스가 AWS에서 빌릴 때는 사용하고 있는 용량만큼만 지불하기 때문에 차익에서 돈을 버는 구조에요
회사의 비즈니스 모델과 가치는 많이 달라요
드랍박스는 누구나 편히 사용할 수 있는 클라우드 공간을 제공한다는 것이 가치지만, 비즈니스 모델은 빌린 만큼 사용하지 않는 차익을 노린 것이에요
드랍박스는 AWS를 벗어나보려고 노력했었지만, 포기하고 슬그머니 다시 AWS로 돌아왔어요
MS Google Oracle 등을 다 합쳐서 10배를 곱해도 AWS보다 작아요
클라우드 산업에서 MS가 굉장히 열심히 쫓아오고 있어요(Window 제품군, Office365)

오늘 아마존 제프 베조스 CEO가 주주들에게 보내는 편지 공개했습니다. . 연매출 1360억 달러(153조 6392억원), 시가총액 4276억 달러(483조 4018억원), 20년 역사의 거대기업 아마존이 갓 창업한 스타트업처럼 움직이는 비결이 담겨 있습니다. 
일단 키워드부터 정리해봤어요. 
(1)고객 중심 회사 만들어라 : 기술 중심, 경쟁자 중심, 제품 중심 있지만 고객중심이 가장 핵심. 고객은 언제나 만족을 모르기 때문)
(2)프로세스에 함몰되지 마라 : 프로세스가 회사를 지배하는지 내가 회사를 지배하는지 반성해야)
(3)시장조사, 설문조사는 독이다 : 조사결과 55%가 만족한다고 해서 제품 출시하지만 47%는 불만족인 것을 놓친다. 
(4)직관을 발전시켜라 : 훌륭한 발명가와 디자이너는 고객을 깊게 이해하고 그 직관을 발전시키기 위해 엄청난 에너지를 들인다
(5)트렌드에 민감해라 : 강력한 트렌드를 포용하지 않으면 뒤쳐진다. 지금은 인공지능과 머신러닝이다. 
(6)빠르게 의사결정하라 : 고도의 의사결정을 늦게 하면 역동성 떨어져. 
(7)목표 불일치를 조기에 인식하라 : 각 팀은 다른 목표와 다른 견해를 가지고 있다. 의사 불일치를 인식하고 조기에 해소해야.
*기사나 요약보다 원문을 읽으시는게 좋을 것 같습니다. 비교적 쉬운 영어로 돼 있습니다. 특히 스타트업 대표님들은 필독인 것 같습니다. 기존 기업 경영자들은 자신들이 최고경영자여서 남들로부터 아무것도 배울게 없다고 생각하지 않는 이상 베조스의 경영 비결을 보고 반성하거나 오히려 극복하고 발전시켜볼 계기를 만들어보는 것도 좋을 것 같습니다. 
https://www.sec.gov/Archives/edgar/data/1018724/000119312517120198/d373368dex991.htm


swap은 오퍼레이션이 3개이에요
임시 변수 할당, 바꿀 값, 바꾼 곳에 임시 변수 할당
미루는 것과 swap은 달라요, 변수 자체를 1/3 계산 오버헤드를 줄일 수 있어요
swap의 연속이 아니라, 들었다가 필요한 곳에 찾아넣는 방식이 좋아요

TV는 전자총을 가지고 위에서 아래로 계속 그려주는거에요
사람이 자연스럽다고 생각하는 칼라는 16만 칼라에요
16.67 밀리세컨드가 1프레임

모든 GUI 프로그램은 화면을 1초에 60번 정도 그려줘요
main에서 프로그램이 꺼질 때까지 계속 무한 루프를 돌면서 loop(); 라는 함수를 호출해줘요
(이벤트 루프)
loop 함수는 화면을 그려주는데 레이어로 그려줍니다
R/G/B/투명도 00~FF : 하나의 점을 찍을 수 있어요 (4byte)
화면을 채우려면 4byte * 가로 길이 * 세로 길이의 메모리를 확보해야 해요
메모리 공간을 두 개를 만들어서 그리려는 화면이 완성되면 바꿔치기해요, 
버퍼링이라고 해요
첫 번째 루프와 두 번째 루프 사이에 텀을 두어서 강제로 초당 60장만 그리도록 제한을 걸어요
(컴퓨터는 1초에 2만 장을 그릴 수 있어요)
화면을 누른 순간 메시지 큐에 여러분들의 액션이 모두 저장되어요, FIFO
큐가 처리되기까지 1/60 이내의 시간차가 존재하지만 사람은 인지하지 못해요
이벤트에 대한 이벤트 함수를 콜백으로 구현하면, 해당 이벤트가 메시지 큐에서 처리될 때 호출되는 것이에요
IO와 같은 작업은 늘 비동기로 짜야 해요
게임에서 버튼을 눌렀을 때 반응하게 하려면 1/60 초 이내에 처리될 수 있도록 로직을 짜야 해요
그렇지 않으면 화면이 늘어집니다, 그걸 렉이라고 하지만 실제로는 루프와 루프 사이에 텀이 생긴 것이에요, Network나 GPU로 인해 발생하는 경우가 다수에요
예전에는 멀티 스레드로 처리했었는데, 요새는 비동기 테스크로 처리를 해줘요
게임을 만들어보시면 여러분들의 사고 지평이 넓어지는 기회가 될거에요

2진수 <-> 16진수
2진수로 바꿀 때는 계속 2로 나누면서 만들어주면 되어요
2진수를 16진수로 바꿔줄 때는 4자리씩 끊어서 계산해요
상호 간의 전환이 정말 쉬워요

1byte가 8bit
bit는 0, 1을 표현할 수 있는 단위
16진수 두 글자가 1byte에요
4byte는 32bit

int = word = 가닥수 = 4byte

i386, x64

선형대수 이산수학 통계가 컴퓨터공학에서 중요한 수학분야에요

배열에 중복된 숫자 찾기

연결 리스트 : 노드와 포인터로 연결된 선형 자료구조, 노드는 아이템, 포인터는 다음 노드의 주소
배열은 메모리에 물리적 저장되는 방식이에요
배열은 원소를 읽을 때 복잡도가 O(1)이에요, 왜? => 인덱스를 알고 있으면 바로 접근할 수 있어서
링크드리스트가 임의의 노드로 가기 위한 복잡도는 O(N)
Array List는 배열과 달리 업데이트에 유리한 자료구조, Array(배열)은 읽기에 유리한 자료구조에요
빈번한 업데이트가 있다면 링크드리스트를 사용하세요, 최근에는 Red-Black-Tree라는 것을 많이 사용해요
RBT로는 Binary Search를 통해 LogN의 복잡도를 통해 접근할 수 있어요
링크드리스트와 배열의 읽기 쓰기 모두 중간 정도의 성능이에요(제네럴 리스트에요)
링크드리스트 중에서 더블 서큘라 링크드 리스트를 가장 많이 써요

Stack : 아래에서 탑처럼 쌓아놓는 것을 다 스택이라고 해요(LILO)
옷거는 공간은 옷장의 캐시에요, 캐시는 사용빈도가 높은 것들을 모아두어야 해요,
캐시는 가까운 시간 내에 사용할지(최신성, 리센시), 얼마나 자주 사용하느냐(빈도, 프리퀀시) 가 높은 것을 캐싱해두어야 해요
자주 안 사용할 것은 victim으로 골라서 옷장으로 보내줘야 해요
Victim 선정 기준은 사용한지 오래된 것, 자주 안 쓰는 것, 데이터 사이즈가 큰 것이에요

Queue : FIFO
Deque : Stack + Queue, 내 마음대로 뺄 수 있어요
- 배열로 구현하면 앞에 있는 자료를 뺄 때마다 앞으로 다 옮겨줘야 해요
- 그래서 양방향을 위해 더블 링크드리스트로 구현해야 해요

사용 빈도는 Array List, Hash, Double Linked List 순이에요

Java의 LinkedList는 Deque와 List를 상속받았어요(=Double Linked List에요)
Implement라는 것은 강제하는거에요

클라이언트 개발자는 Object, Array를 가장 많이 사용하게 되어요

- Linked List나 Array를 사용한다
- 담아야 하는 데이터 : a1, a2 ... an, b1, b2 ... bn
- size() 불가, 전체 size 짝수
- 결과 : a1, b1, a2, b2, ... an, bn

runner(링크드리스트 사용 테크닉)
참조를 하나는 1씩 하나는 2씩 증가시키면
2씩 증가시킨게 끝부분을 통과하게 되면
1은 가운데에 위치하게 된데요
이거 쓰면 루프 하나 없앨수 있다고 했어요
끝을 통과하면 링크드 리스트 같은경우는
가리키는 값이 null이 되겠죠

해시는 키를 이용해서 값을 찾고 싶을 때 사용해요
접근할 때 평균적으로 O(1)이에요
bucket이 일종의 배열이에요

해시맵(동기화 미지원), 해시테이블(동기화 지원)
성능은 해시맵이 더 좋지만, 여러 명이 사용해야 하면 해시테이블을 써야 해요

Hash 구현하기
좋은 Hash함수란 충돌이 발생하지 않는 것이에요
선형조사
Hash는 Table의 원소가 많아질수록 조사해야할 것이 많아서 느려져요
본래 공간의 절반 정도는 쓰지 않아요
구현하지 못 하더라도 동작원리를 이해해보세요

Linked list 각각의 차이점, Hash의 원리
자료구조는 만드는 것보다 잘 쓰는 것이 중요해요!

알고리즘 문제는 자료구조를 하나로만 구현하려고 하지 말고, 여러 개를 조합해서 사용해서 해결하는 것이 훨씬 좋아요!

컴퓨터과학에서의 많은 부분은 Convention으로 인한 것이 많아요

CPU는 register와만 연결되어있어요
Data pyramid
HDD -> Memory -> L2 Cache -> L1 Cache

데이터 최초 요청시 cache miss(cache에 데이터가 없음) -> cold miss(최초 디스크에서 메모리로 올림)
안 쓰는 프로그램을 고르는 것을 victim을 찾는다고 해요, cache(buffer) replacement algorithm
LRU least Recently Used, 이것을 O(1)로 찾으려면?
Locality (temporal locality = 리센시 데이터를 읽을 가능성이 높다, special locality = 10번지를 읽으면 9, 11 번지를 읽을 가능성이 높다)

덱은 더블링크드리스트로 구현되어있어요
LRU Stack = Deck
hit(page) -> remove(page) -> Add first(page)

배열을 쓰려고 했는데, O(1)이 안 나오고 O(N)이라면 더블 링크드 리스트를 하나 추가했더니 문제가 더 추가되어서, 해시 테이블을 추가했더니 알고리즘 성능은 O(1)이 되었지만, 공간복잡도와 코딩이 증가했다(버그양산확률이 올라감)
내가 원하는 알고리즘 성능이 안 나온다면 List나 Hash Table을 추가해볼 생각을 해보세요

적당한 자료구조를 잘 가져다써야 한다


윤희님 강의내용!
링크드리스트는 자료구조이면서 다른 자료구조를 만들어줄 수 있도록 하는 원자에 해당
- 4종류가 있으며 싱글/더블, 서큘라여부로 나뉨
- 흔히 생각하는 자료구조들 내부는 사실 다 링크드리스트로 구현되어있을 것
- 면접관들은 API만 아는 것이 아니라 내부 원리를 제대로 이해했는지를 보고자 한다

자료구조 : 스택, 큐, 덱, 트리, 그래프, 해쉬테이블

Array List는 Linked List로 만든 배열이에요, 이 아이는 Update가 쉬운 대신에 탐색하는데 O(N)이 소요되고, Array는 읽기가 O(1)인 대신에, Update시에는 O(N)
Array List는 초기에 설정한 size를 변경하는데 Array에 비해서 어려움이 매우 적어요

Honux
Q. Array는 Linked List가 아닌 다른 것으로 만들어져있나요?
Q. Primitive의 반대말은?

이진탐색트리의 시간복잡도는 log2N이에요

J. Javascript으로 Linked List를 구현해오세요! (Operator 값추가, 값 프린트, 넥스트, 값 삭제)
​```javascript
const LinkedList = function(data, next = null) {
  this.data = data;
  this.next = next;
};

LinkedList.prototype = {
  print() {
    console.log(this.data);
  },
  find(number) {
    let result = this;
    for (let i = 0; i < number; i++) {
      result = result.next;
    }
    return result;
  },
  add(Node) {
    this.next = Node;
  },
  delete() {
    this.next = null;
  }
};

const firstNode = new LinkedList('first');
const secondNode = new LinkedList('second');
firstNode.next = secondNode;

console.log(firstNode);
console.log(firstNode.find(1));
firstNode.delete();
console.log(firstNode);
​```

J. runner 구현
​```javascript
function solution(arr) {
	const resultArr = [];

	function runner(arr) {
		for (var i = 0, j = 0; arr[i] !== undefined; i+=2, j++) {}
		return i;
    }

	const max = runner(arr)/2;
	
	for (let k = 0; k < max; k++) {
		resultArr.push(arr[k]);
		resultArr.push(arr[k+max]);
    }

	return resultArr;
}

solution([1,2,3,4,5,6]);
​```

J. Insertion Sort(템플릿 코드 보고 해오세요)
https://gist.github.com/honux77/31f67eabf0996a8656d3146ed19afb12
```

```java
package honux;

public class MyList {
	public Node head, tail;
	public MyList() {
		head = tail = null;
	}
	
	public Node next(Node n) {
		return n.next;
	}
	
	public void add(int i) {
		Node n = new Node(i);
		if(head == null) {
			head = tail = n;
		} else {
			tail.next = n;
			tail = n;
		}
	}
	
	public void print() {
		Node current = head;
		while(current!= null) {
			System.out.print(current.item + ", ");
			current = current.next;
		}
		System.out.print("\n");
	}
	
	public static void main(String[] args) {
		MyList list = new MyList();
		for (int i = 1; i <= 10; i ++) {
			list.add(i);
		}
		
		Node n = list.head;
		int count = 0;
		while (n != null) {
			n = n.next;
			count++;	
		}
		System.out.println(count);
		
		MyList list2 = new MyList();
		Node n2 = list.head;
		n = list.head;
		
		for (int i = 0; i < count /2 ; i++) {
			n2 = n2.next;
		}
		
		System.out.println(n.item + "," + n2.item);
		
		for (int i = 0; i < count /2 ; i++) {
			list2.add(n.item);
			list2.add(n2.item);
			n = n.next;
			n2 = n2.next;
		}
		
		//result
		list.print();
		list2.print();
		
	}
}


/*
Need to create Node.java in the same package

package honux;

public class Node {
	int item;
	public Node next;
	
	public Node(int i) {
		item = i;
		next = null;
	}
}
*/

package honux;

/**
 * Simple Hash implementation 
 * It can't expand and no exception handling for put!
 * 
 * @author honux
 *
 */
public class MyHash {
    private final static int TABLE_SIZE = 128;
    private int count = 0;
    HashEntry[] table;

    public MyHash() {
          table = new HashEntry[TABLE_SIZE];
          for (int i = 0; i < TABLE_SIZE; i++)
                table[i] = null;
    }

    public int get(int key) {
          int hash = (key % TABLE_SIZE);
          while (table[hash] != null && table[hash].getKey() != key)
                hash = (hash + 1) % TABLE_SIZE;
          if (table[hash] == null)
                return -1;
          else
                return table[hash].getValue();
    }

    public void put(int key, int value) {    		  
          int hash = (key % TABLE_SIZE);
          while (table[hash] != null && table[hash].getKey() != key)
                hash = (hash + 1) % TABLE_SIZE;
          table[hash] = new HashEntry(key, value);
          count++;
    }
}

class HashEntry {
    private int key;
    private int value;

    public HashEntry(int key, int value) {
          this.key = key;
          this.value = value;
    }     

    public int getKey() {
          return key;
    }

    public int getValue() {
          return value;
    }
}
```

---

### 170417

```
Gulp, Grunt 같은 것들을 Task Runner라고 해요

Webpack도 그런 것들 중 하나에요
Merge, Linting, Module loader, transpiling(sourcemap)

우리는 원본파일을 표준대로 잘 짜기만 하면, 이 도구를 통해서 브라우저에서도 사용할 수 있는 코드로 변환해줘요

Build Tool이 이제는 Webpack으로 통일되어가는 추세에요
Build Tool을 한 번 선정하면 바꾸는 것이 참 어려워요, 기존 것으로 잘 되던 것을 바꾸기가 부담스럽기 때문이죠

프론트엔드 분야는 서버에 장애를 일으키는 경우가 거의 없으므로, 자주 업데이트해줄 수 있다고 생각해요, 한 번 업데이트를 미루기 시작하면 따라잡기 어려워져요

간단한 부분들은 webpack없이 npm script를 통해서도 개발할 수 있어요

개발도구 세팅은 논리적인 부분도 아니고, 어려움이 많아요
검색을 해도 나와 맞는 것을 찾기도 어렵고, 원리를 이해하기 어려워요
빌드 도구가 하는 역할이 너무 많아서 내가 원하는 조합을 어떻게 찾아야 하기도 어려워요

Create React App은 핵심 플러그인 외에는 제공하지 않아요
추가 설정이 필요하면 eject를 통해 끄집어내야 해요

빌드 환경은 개발용(development)과 배포용(production)을 구분해서 관리해요

development : dependencies + devDependencies, Sourcemap, Live Reload / for Debugging
production : dependencies, for 최적화(난독화)

development build 외에도 production build를 주기적으로 해봐야 문제점을 찾을 수 있어요

bundle : dependency를 파악해서 하나의 파일로 합쳐주는 과정

Create React App에서 eject해서 해보고, 필요할 때마다 loader를 하나 하나씩 추가해보세요

jsx babel sass react webpack2

beta는 쉽게 바뀔 소지가 있기 때문에 Production용에 적용하면 안 되어요

Create React App를 이해하고 싶으면 npm start부터 추적해보세요



최종적으로 보여지는 페이지가 무엇이냐? -> 엔드페이지

많은 문제점
유저가 기대했던 것과 다른 페이지, 원하는 정보를 찾기 어려운 페이지, 이미지가 통으로 되어있는 페이지

삼성에서 새로운 핸드폰이 출시하기 전에, 네이버 카카오톡 등 유명 서비스에 대해선 QA를 미리 다 해요

다행히도 모바일은 표준이 잘 지켜져있어요, 비슷한 Webkit을 사용해요

모바일 웹은 간결하고 단순한 것이 좋아요
쓸데없이 애니메이션을 다 빼버리세요

개발은 절반, 기획과 싸우는 것이 절반

모바일 앱에 익숙하기 때문에, 모바일 웹에서도 애니메이션을 기대하는 경우가 많아요

애니메이션은 CSS3를 사용해서 하세요

setTimeOut, setInterval, requestanimationframe 각각은 어떻게 다른가?

opacity : 투명도
opacity, filter, transform 와 같은 property들은 gpu를 사용한 것이어서 성능상 이점이 있어요(GPU Acceleration Property)

http://d2.naver.com/helloworld/2061385

반복적인 애니메이션은 keyframes를 사용

Mobile Touch Move는 Touch Start없이는 구현이 안 되어요
(마우스는 누르지 않아도 이동가능)

마우스는 움직여서 변화하는 경우는 거의 없어요

기울기나 시작점과 끝점의 길이 차이 등을 기반으로 여러 애니메이션들을 구현해요

touches는 별로 의미가 없고 changeTouches를 쓰다가 막히면 다른 것을 찾아쓰세요
(변화가 일어난 것만 changeTouches에 담겨요)

media query는 (보통 width를 기반으로) 분기처리를 하는 것이에요
기본적으로 원래 있는 CSS를 다 적용하고, 따로 지정한 부분만 바꿔줘요

꼭 데스크탑을 모바일보다 먼저 구현할 필요는 없어요 (편견을 가지지 마세요)
모바일은 핵심만 담아내기 때문에, 먼저 만들고 나중에 살을 더 붙여서 데스크탑을 만드는 것도 가능해요

모바일과 연결해서 브라우저는 모바일, 디버깅은 PC에서 작업해서 하는 것이 가능해요
https://developers.google.com/web/tools/chrome-devtools/remote-debugging/
브라우저에서 모바일 해상도로 보면, 화면은 거의 비슷하긴 하지만 모바일 기기로 보는 것과는 달라요(지원 API, 속도 등)

Proxy, 피들러 와 같은 것도 있어요

라이브러리 없이 모바일 웹, 애니메이션을 구현해보세요
```

---

### 170419

```
- Readme도 이쁜걸 가져다가 써보시길.
- 페이코딩을 해보자! 보다는 '페어코딩을 매주 언제 어떻게하자' 라는 목표가 더 좋음.
- "팀원들 간의 소통을 자주 하고, 우리는 팀 이라는 정체성을 가지자" 보다는 의도적인 구체적인 커뮤니케이션 장치(시간이나 규칙)를 만드는 것도 방법임.
- 백로그를 어떻게 주기적으로 업데이트해서 살아 있는 문서로 만들지 항상고민해보기.
- 프론트엔드-백엔드에 대한 하나의 싸이클을 대상으로 진행하면 더 좋겠음. 예를들어 2주까지 게임구현을 프론트-백엔드까지 완성하기, 로그인은 그 다음주에 프론트-백엔드까지 완성하기.
- https://github.com/pycraft114/octodog/milestone/1 <- 마일스톤에 이번주의 목표가 표현되면 좋겠음.
- 다루는 기술을 깊게 공부하자. 양보다는 질이다.
- 리덕스가 익숙해질때까지 복잡한 개념과 라이브러리를 자제하는 것도 팁
- 스터디를 하면서 프로젝트 진행하는거 자연스럽고 당연한일이다. 그렇게 가능한 방법을 찾아서 시도하시길.
- 매일 회고를 하고 팀의 상태를 개선하려고 의도적으로 노력을 하세요.
- 충분히 토론하고 결정된 건 최대한 잘 따르자.
- 각자 한 일에 대해서 리뷰를 갖는 시간을 많이 갖도록 하자.
- 링크 공유.
   https://github.com/DongHyunKims/jinnecast/wiki/Team-Rule
   https://docs.google.com/presentation/d/1qk_wO3yx6cSFEFea03sb468y3EAK5KQNlZxsczvgTiI/edit#slide=id.g2077e5b22c_0_77
   
좋은 css 코드란? 이라는 질문에 짧은 대답.
---
css도 읽기좋은 형태로 구현하는게 좋죠.
이렇게 짜도 되고, 저렇게 짜도 돌아가기때문에 좋은 패턴이 있긴해요.
예를들어, selector를 불필요하게 길게 쓰지 않고 간단하게 표현하고, class를 잘 활용하는 등.

이런 글의 bad/good을 비교해보시면 좋겠어요.
http://learn.shayhowe.com/html-css/writing-your-best-code/

또한 less나 sass를 쓰는 것도 나중에 수정할때 좋기때문에,
좋은 패턴을 유도하는 방법이라고 생각해요.


react 관련 플러그인을 너무 많이 처음부터 쓰지 않아도 돼요.
예를들어 로직과 서비스 개발이 되면,
router 를 추가로 적용할 수 있고, (약간의 수정이 필요할 수도 있지만)
인증로직도 넣을 수 있는거겠죠.
비동기도 일단 처리할 수 있고, 더 나은 방법이 있다면 단계적으로 적용할 수 있을거에요.
프레임워크를 조금 가볍게 시작하는 것도 방법이라 생각해요.
```

---

### 170420

```
운영체제는 정부와 같다, 자기 자신은 하는 역할이 없지만 다른 프로그램들이 잘 돌아가도록 도와주는 역할을 한다

연산 CPU, 프로세스 Memory

하드웨어들은 모두 하드웨어 컨트롤러가 있어요
각각의 컨트롤러들은 작은 컴퓨터라고 보시면 되어요

버스라는 공동의 데이터 통로가 있어요

CPU 바로 밑에 Register -> Cache -> Memory

Thread는 실이라는 뜻이에요, 가벼운 프로세스, CPU에서 실행되고 있는 것

프로그램 카운터, 현재 내 프로세스가 어디를 실행하고 있는지 알려주는 역할(Register에 있어요)

운영체제의 핵심에 해당하는 것이 커널이에요

인류의 역사상 단기간동안 가장 빠른 발전을 해온 것이 컴퓨터과학이에요

운영체제의 주요 업무중 하나는 하드웨어를 보호하는 것이에요

메모리에 있는 변수들끼리의 연산은 메모리에서 할 수 없어요, 레지스터로 전달하고 Adder를 통해 다른 레지스터에 결과값을 전달하고, 그것을 메모리에 올리는 방식으로 진행해요

레지스터는 지금 쓸 것 같은 것 하나만, 캐시를 내가 쓸 것 같은 것들 뭉텅이

책을 읽을 때, 책을 캐시에 올리고, 내가 보고 있는 해당 한 페이지는 레지스터에 있는 것

비동기(Async, Non-blocking), 동기(Sync, Blocking)의 차이
동기 Non-blocking도 있어요(해당 작업이 가능하지 않은 경우에는 Error를 발생시켜요)
비동기를 하고 싶지 않으면 멀티스레드를 쓰세요

파일은 항상 open read write close의 절차를 거쳐요

Node.js가 좋은 이유는 Single Thread + Async로 Context Switch Overhead가 없기 때문이에요

이해를 못 하겠다면 단어라도 들어두세요-

부모없는 프로세스는 존재하지 않습니다
크롬을 실행시키면 GUI 프로그램이라는 부모의 프로세스를 클론하고, 그것을 크롬으로 변신시킵니다
```

---

### 170424

```
예매와 같은 서비스에서는 이력관리가 매우 중요할 수 있어요

구글은 디자인은 심플하지만 사용자 경험은 훨씬 편할 수 있어요
그와 달리 한국 사이트(네이버, 다음) 등은 디자인은 훨씬 화려할지 몰라도, 사용자 경험은 그렇지 않은 경우도 있어요

React를 사용하지 않으면 history.js와 같은 라이브러리를 쓰면 되지만 React를 쓰는 우리는 React Router가 적합할거에요

Ajax를 Cache해두었다가, 이전 이후 페이지 이동 시에 활용하여 렌더링해주면 아주 좋아요

프레임워크마다 필요한 방식으로 만드는데, React는 Component를 통해 만들어요

View State, Link State는 당연히 밀접한 연결관계를 가지고 있어요

사용자가 해당 history를 기대하느냐가 매우 중요하다
사용자가 이전 페이지를 눌렀을 때, 무엇을 기대하는가?

과거에는 클라이언트 사이드에서 할 수 있는 일이 매우 적어서 요청하고 받는 것 밖에 없었는데,
이제는 데이터 관리까지 하는 것으로 가용역할이 넓어지고 있어요

NavLink와 Route 적용만 해도 훌륭하지만, 인증 로직까지 넣어볼 수도 있어요!(로그인 여부)
+ 이전 페이지에서 내가 보고 있던 위치를 다시 보여주는 기능
+ 회원가입 전에 보고 있던 페이지를 보여주는 기능
+ 로컬스토리지를 확인해서 인증 정보 유무, 그것이 정말 유효한지 ComponentDidMount 내 코드를 통해 서버에 Ajax보내서 검증, 유효하지 않으면 로그인 페이지로 렌더링, 로그인하고 나면 처음에 인증 정보 확인하던 시점의 페이지로 돌려주기

React Router를 사용하는 것은 1차적이고, 그것의 동작원리를 설명할 수 있어야 해요!

https://tylermcginnis.com/build-your-own-react-router-v4/
꼭 읽어보세요!

왜 필요하고, 내부에서 어떻게 동작하고, 어떤 API를 쓰는 것이겠네
(단순 API를 아냐 모르냐는 찾아보면 되는 문제이니 중요하지 않다)

라이브러리를 모두 흉내내려하지 말고, 핵심만 담아서 구현해보세요
(React Router의 v4가 아닌 v0.1을 따라해보세요)

"요즘 강의로 VanillaJS를 지나,
Redux, Router, Promise와 같은 녀석들을 다루는 단계 쯤.
그런데 추상화된 코드의 이해는 역시나 어렵고 고민스럽다. 프로젝트 과정을 거쳐도 동작에 대해 왜, 어떻게는 참 어렵다. 
그래서 종종 이녀석들을 직접 만들어 보시라는 요구도 하게 된다.
이번주에는 Promise나 fetch API라도 직접 만들어 보시라 할까 고민중;;"
```

---

### 170426

```
비동기는 UX에서 중요한 기능이다(사용성이 좋게 만들기 위해)

비동기 함수에서 비동기 함수를 호출하는 경험을 해본적 있는가?

비동기에서는 에러 처리도 비동기 안에서 처리해줘야 해요(catch)

Async 등으로 처리하다보면 마치 동기처럼 보이지만,
실제로는 내부 로직에도 비동기가 숨겨져있기 때문에 복잡도가 증가하게 된다
그렇더라도 그 비동기 뭉텅이 안에서라도 동기적인 코드처럼 동작시켜보자!

사실 콜백헬 자체는 애초에 로직이나 API 자체를 우선적으로 해결하려고 해야 한다

generator는 비동기를 위해 탄생한 아이는 아니고, 애니메이션 조작 등에 유용해요, 활용도가 아주 높진 않아요, 비동기 처리할 때도 유용하지만 Promise -> Async/Await으로 가는 것이 더 좋을 것 같아요

generator는 함수의 return을 멈추게 할 수 있어요, 원하는 지점에 yield를 표시해놓고 함수 바깥에서 실행을 조작할 수 있는 함수에요(겉으로 보기엔 breakpoint와 비슷해요), 비동기 로직에도 적용할 수 있어요, run할 때마다 다음의 yield까지만 실행시키는 등의- 많이 안 쓰이고 있어요

Promise가 중요한 것은 generator와 Async/Await 모두 Promise 기반이기 때문이에요
(Promise도 ES6 기반이므로 Babel이 필요해요)

내부 코드가 어렵기 때문에, 사용법 위주로 먼저 익혀보세요
then에서 Promise 객체를 반환하기 때문에 Method Chaining을 할 수 있어요

프론트엔드 개발자가 비동기를 만나는 것은 Ajax의 연속인 경우가 매우 많아요

Promise가 호출될 때 then 자체는 실행이 바로 되지만, then이 인자로 가지고 있는 콜백함수들은 resolve가 호출되는 시점에 실행됩니다

resolve와 then을 Promise없이 직접 구현해보세요(SetTimeOut을 활용해야 해요 소근소근, time값은 0)

동작은 Callback Hell과 똑같지만, 보여지는 코드가 다른 것

Ajax 처리할 때, Fetch API를 사용하면 좋아요

우선 Promise 표준대로 처리해보는 것을 추천해요
Promise를 이해하면 Async/Await은 20분이면 익힐 수 있어요

Redux를 사용하게 되면, Middleware를 통해서 함수를 통해 Action가 동작할 수 있도록 해서 비동기 로직을 넣어서 처리할 수 있어요, Redux-Chunk
```