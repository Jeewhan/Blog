layout: post
title: "장바구니 만들기"
categories: Dev
tags: Dev
date: 2019-06-24

---

이번에 주어진 요구사항은 장바구니 관련 개선이었다



관련하여 정리해본 요구사항은 다음과 같았다

0. 장바구니 페이지에서 스토어 + 최신순으로 옵션을 나열한다
1. 마이페이지에서 장바구니에 최근 담은 옵션 4가지를 보여준다
2. Nav에서 장바구니에 담긴 총 옵션 개수를 배지 형식으로 보여준다



상품은 여러 가지 옵션을 가진다

사용자는 특정 상품을 사는 것이 아니라, 특정 상품의 특정 옵션을 구매하는 것이어서 옵션이라 지칭한다



아래 순서로 옵션을 담는다고 가정해보자

0. 가(스토어) + a(옵션)
1. 가 + b
2. 나 + 1
3. 나 + 2
4. 가 + c



그러면 보여줘야 하는 순서는 다음과 같다

가

- c
- b
- a

나

- 2
- 1



API로부터 받아오는 데이터는 최신순으로 옵션이 담긴 배열이다 (아래는 단순화한 예시)

```javascript
[
  { name: 'c', store: '가' },
  { name: '2', store: '나' },
  { name: '1', store: '나' },
  { name: 'b', store: '가' },
  { name: 'a', store: '가' }
]
```



그렇다면 해야 할 일은 아래와 같다

0. 옵션 배열을 통해 그룹핑해야 하는 스토어가 무엇무엇이 있는지 파악
1. 스토어를 기준으로 옵션들을 그룹핑해서 보여줄 수 있도록 전처리



처음에는 아래와 같은 형태를 생각했었다

```javascript
{
  '가': [ 'c', 'b', 'a' ],
  '나': [ '2,', '1']
}

options.reduce((acc, { name, store }) => {
  if (acc[store]) acc[store].push(name);
  else acc[store] = [name];

  return acc;
}, {})
```



그런데 위 형태를 생각하고 보니, 장바구니 페이지에서 보여주어야 할 때 Object.keys를 통해 스토어명을 가져와야 한다

Object.keys를 쓰는 것이 썩 마음에 들지는 않았고 또한 스토어명이 과연 내가 원하는 순서가 보장될 것인가에 대해 고민하게 되었다

그리고 전체 옵션 개수를 파악해야 할 때 reduce를 써야하는 부분도 아주 좋지는 않았다

그러고 보니 얼마 전에 다른 스터디에서 지인 분의 코드에서 보았던 Map이 떠올랐다



그러니 우선 MDN을 통해 Map에 대해 알아보았다 [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)



The **Map** object holds key-value pairs and remembers the original insertion order of the keys.

첫 문장에 이미 내가 원하는 조건 중 하나가 충족되었다 (순서보장)



The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and `Symbol` keys, so traversal of an object with ie only string keys would yield keys in order of insertion)

위 문장대로라면 Object를 통해서도 목적을 달성할 수는 있다



그러나 아래 세 문장의 측면에서 Map이 훨씬 적합하다

- A `Map` is an [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable) and can thus be directly iterated, whereas iterating over an `Object`requires obtaining its keys in some fashion and iterating over them.
- 
  A `Map` may perform better in scenarios involving frequent addition and removal of key pairs.
- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.



그래서 아까의 코드를 변경하게 되었다

```javascript
[
  ['가']: [ 'c', 'b', 'a' ],
  ['나']: [ '2,', '1']
]

options.reduce((acc, { name, store }) => {
  if (acc.has(store)) acc.get(store).push(name);
  else acc.set(store, [name]);

  return acc;
}, new Map())
```



하지만 이렇게 되니까 요구사항 1번과 2번이 처리하기 번거로워진다



1. 마이페이지에선 4개까지만 보여주기
2. 옵션 전체의 개수 보여주기



Map으로 묶음으로서 스토어 순서에 따라 4개를 보여주는 것은 기존 API의 형태보다 훨씬 더 수월하지만, 반대로 시간순으로 4개를 보여주기는 어려워졌다

또한 옵션 전체의 개수를 보여주기 위해선 여전히 reduce가 필요하다, Map의 size는 key의 개수를 보여주기 때문이다

따라서 범용성을 생각하면 본래의 API 형태로 Redux Store에서 들고 있되, 렌더링을 위해 필요한 시점에 Map으로 묶어주는 것이 좋다고 판단을 내렸다

또한 불변성을 확보하기 위해서 보통 많이 사용할 immer에서도 Map을 지원해주지 않는다

따라서 불변성을 확보하기 위해선 기존 state를 iterable로 변환하여 배열 형태로 치환하여 새롭게 Map을 만드는 과정이 필요하므로 코드 가독성 측면에서도 좋지 않다

id를 기준으로 데이터 유무 또는 해당 데이터에 접속하는 것은 배열에 비하면 O(1)로 처리할 수 있고 가독성도 훌륭하지만, 장바구니 페이지에서 선택기능을 구현할 때는 이미 선택된 상품인지 찾을 때 외에는 (불변성 확보를 위해 계속 새롭게 만들어야 하므로) 큰 이점이 없어진다



장바구니를 구현할 때는 이미 선택된 상품들을 조회해야 하는 경우가 많은데, 이때는 useMemo가 매우 유용하게 쓰였다

선택된 상품들이 필요한 기능마다 useMemo로 캐싱해둔 데이터를 시작점으로 삼아 해당 기능에 필요한 로직만 붙여주면 되었기 때문이다



요구사항별로 다르겠으나, 장바구니 -> 주문하기 -> 쿠폰적용 등까지 대상 상품들이 이어진다면, 각 상황에 맞추어 타입스크립트의 타입을 조금씩 바꿔가는 것도 유의미할 것 같다

장바구니에서 상품을 다루는 타입인 ICartViewModel의 status는 SALE, SOLDOUT 등으로 다양하지만 ICartViewModel을 extends한 IOrderProductViewModel의 status는 반드시 status이며 쿠폰적용을 위한 프로퍼티들을 추가적으로 갖도록 설계하였다

타입을 통해 주문하기 페이지에 들어와선 안 되는 데이터들을 검증하고 나면 코드의 중복도 적어지고, 실수로 중복을 허용했을 때 피드백을 받을 수 있으므로 Model 관련 코드에만 타입스크립트를 적용했을 때와 또 다른 이점을 맛보고 있다

