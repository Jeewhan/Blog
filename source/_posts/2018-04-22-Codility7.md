---
layout: post
title: "Codility ~7"
subtitle: "실용적인 알고리즘"
categories: Algorithm
tags: Algorithm
---

# 실용적인 알고리즘 (3) - Codility ~7

> 문제 앞에 * 이 붙어있으면 어려웠던 문제이다

이 글은 해답은 보고 싶지 않고, 문제 풀이는 막혀서 힌트만 받고 싶은 (아래 문제들을 풀 때의 나와 같은) 사람들에게 도움이 되는 것을 목표로 작성하였다

## Prefix Sums

### [CountDiv](https://app.codility.com/programmers/lessons/5-prefix_sums/count_div/)

문제에서 요구하는 시간복잡도가 O(1)이므로 loop 없이 식을 거치면 바로 결과를 반환할 수 있어야 한다

실제 문제 난이도에 비해서 한참 헤매었던 문제인데, **나눗셈**의 의미를 생각해보고 **케이스 분류**만 잘 하면 쉬운 문제이다

[내 코드](https://app.codility.com/demo/results/trainingFJEKVX-9DK/)

---

### [PassingCars](https://app.codility.com/programmers/lessons/5-prefix_sums/passing_cars/)

문제에서 요구하는 시간복잡도가 O(N)이므로 한 번의 loop만으로 문제를 해결해야 한다

따라서 **stack**을 활용해야 했다

[내 코드](https://app.codility.com/demo/results/trainingTFAZYA-4ZF/)

---

### * [MinAvgTwoSlice](https://app.codility.com/programmers/lessons/5-prefix_sums/min_avg_two_slice/)

문제에서 요구하는 시간복잡도가 O(N)이므로 **최소값을 기록 및 대조**하면서 loop를 순회해야 한다

이 문제에서 원하는 **부분집합은 2개 또는 3개로 모두 설명될 수 있다**는 점도 중요했다

[내 코드](https://app.codility.com/demo/results/trainingSZNUV4-SX8/)

---

### * [GenomicRangeQuery](https://app.codility.com/programmers/lessons/5-prefix_sums/genomic_range_query/)

문제에서 요구하는 시간복잡도가 O(N+M)이므로, **중복되지 않는 두 번의 loop**를 사용해야 한다

Input의 구간이 어떻게 올지 모르는 상태에서 해당 구간의 최소값을 구할 수 있어야 하므로, 한 번의 loop를 통해 기록을 해두어야 한다

또한 나머지 한 번의 루프를 통해 각각의 기록들을 비교하여 답을 내야 한다다

[내 코드](https://app.codility.com/demo/results/trainingXD537B-EQJ/)

---

## Sorting

### [Triangle](https://app.codility.com/programmers/lessons/6-sorting/triangle/)

[내 코드](https://app.codility.com/demo/results/trainingDJRKKY-XQP/)

### [Distinct](https://app.codility.com/programmers/lessons/6-sorting/distinct/)

[내 코드](https://app.codility.com/demo/results/trainingNEVMH3-VN6/)

설명할 필요가 없는 문제들이다

---

### [MaxProductOfThree](https://app.codility.com/programmers/lessons/6-sorting/max_product_of_three/)

Input되는 배열의 각 요소별 조건이 무엇인지만 유념하면 되는 문제

[내 코드](https://app.codility.com/demo/results/training4QFT9V-QVH/)

---

### * [NumberOfDiscIntersections](https://app.codility.com/programmers/lessons/6-sorting/number_of_disc_intersections/)

우선 접점의 정의를 정확히 찾아보고 시작해야 한다

**stack**을 활용하면 풀 수 있다, 또한 X좌표와 시작지점인지 여부를 동시에 표시해야 하므로 배열을 활용하면 좋다

인터넷에 범위를 점점 줄여나가는 이중 loop로 푸는 해답이 많은데,
문제에서 요구하는 시간복잡도가 O(N*log(N))이므로
stack을 활용하는 방향이 더 좋은 것 같다고 생각한다

[내 코드](https://app.codility.com/demo/results/trainingCQ83SA-5QJ/)

---

## Stacks and Queues

### [StoneWall](https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/)

[내 코드](https://app.codility.com/demo/results/training3C9PXC-NGU/)

### [Brackets](https://app.codility.com/programmers/lessons/7-stacks_and_queues/brackets/)

[내 코드](https://app.codility.com/demo/results/training7WVQ6J-PCQ/)

### [Fish](https://app.codility.com/programmers/lessons/7-stacks_and_queues/fish/)

[내 코드](https://app.codility.com/demo/results/trainingT4DR4Q-YGN/)

### [Nesting](https://app.codility.com/programmers/lessons/7-stacks_and_queues/nesting/)

[내 코드](https://app.codility.com/demo/results/training4W8H2J-F3F/)

전형적인 stack 활용 문제들이다
