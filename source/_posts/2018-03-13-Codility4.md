---
layout: post
title: "Codility ~4"
subtitle: "실용적인 알고리즘"
categories: Algorithm
tags: Algorithm
---

# 실용적인 알고리즘 (2) - Codility ~4

> 문제 앞에 * 이 붙어있으면 어려웠던 문제이다

## Iterations

### [BinaryGap](https://app.codility.com/programmers/lessons/1-iterations/binary_gap/)

문제에서 요구하는 시간복잡도 O(log(N))

=> 이진탐색과 같이, 거듭 2로 나누어서 정답을 구하는 과정이겠구나 라고 예상해볼 수 있다.

2진수 구하는 방법을 기본적으로 익히고 있어야 할 것 같다.

관련해서 떠오른 글

```
Frank Hyunsok Oh

학습 효율을 위해서는 기본적인 언어와 라이브러리 기능 숙지 외에 대충 3가지 층위의 연습이 필요한 것 같습니다.

- 기본적으로 해당 언어에서 자주 발생하는 간단한 과업을 처리할 때 사용하는 숙어를 숙지하는 연습.

예를 들어 C에서 정수 스왑시 a ^= b; b ^= a; a ^= b; 라던지 1중 또는 2중, 3중 for루프를 돌려가면서 삼각형을 그린다던지,

실수를 정수화하는 여러가지 방법이라던지.. 이런 자잘한 숙어를 익혀두고 연습할 수 있는 교재나 도구가 필요한 것 같습니다.


- 여러 숙어를 엮어서 함수(또는 메소드와 객체)를 만들고 이를 엮어서 한가지 API를 제공하는 독립된 단위(모듈이라고 불러도 좋고)을 만드는 연습


- 여러 모듈을 조합해 원하는 목표를 달성하는 애플리케이션을 만드는 연습.

게임도 좋고 개밥 먹기를 위한 간단한 유틸리티도 좋고, 책에서 본 예제를 자신의 방식으로 만들어 보는 것도 좋죠.

요구사항을 추출하고 거기서 프로그램을 설계하고 코딩하는 과정과 그 과정에서 프로젝트 진행과 품질을 관리하고 디버깅하는 경험을 쌓아야 합니다.
```

---

## Arrays

### [CyclicRotation](https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/)

배열에 대한 입출력 메소드를 알고 있는가?

unshift : 배열의 맨 앞에 데이터를 추가하고 길이를 반환

shift : 배열의 맨 앞 데이터를 제거하고 제거된 값, 빈 배열이면 undefined를 반환

push : 배열의 맨 끝에 데이터를 추가하고, 길이를 반환

pop : 배열의 맨 끝 데이터를 제거하고, 제거된 값, 빈 배열이면 undefined를 반환

### [OddOccurrencesInArray](https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/)

문제에서 요구하는 시간복잡도 O(N)

M * N일 수는 있지만 결국은 순회할 때 그 안에서 for문을 하는 등의 작업은 불가능

즉 순회 과정에서 기존에 나왔던 숫자인지 비교하기 위한 로직을 O(1)로 구현할 수 있어야 함

그러기 위해선 그 전에 나왔던 숫자에 대해 저장해놓는 과정이 필요하니, 이것을 Dictionary 형태를 활용해서 구현

(배열 형태로 만들게 되면 배열에서 해당 값이 저장되어있는 위치를 찾기 위해 순회하는 과정이 필요하게 되므로 O(1)이 성립하지 않게 됨)

### [TapeEquilibrium](https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/)

문제에서 요구하는 시간복잡도 O(N)

2-2가 그랬듯이, left와 right를 순회시마다 구할 수는 없음

따라서 순회시마다 변화하는 값을 통해 비교할 수 있어야 함

여기서는 정방향으로 순회시에 순회 때마다 우측에 있던 값이 좌측으로 옮겨가는 구조이므로

순회시마다 값을 좌측에 더하고, 우측에서 빼고 문제에서 차의 절대값의 크기를 구해야 함

이때도 가장 작은 값을 찾기 위해선 기존에 저장해놓은 차이값과 비교해서 더 작으면 덮어쓰고 아니면 Pass하는 방식으로 진행 필요

---

## Time Complexity

### [PermMissingElem](https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/)

문제에서 요구하는 시간복잡도 O(N)

원래 나올 수 있는 숫자를 모두 만들어놓고 없애가면서 남아있는 숫자를 보여주고,

제한사항에 있는 예외사항([]) 등을 처리하는 방식도 가능하지만,

문제의 데이터가 모두 숫자이고, 누락된 하나의 값을 찾는다는 점에서 차를 통해서 구하는 것도 가능합니다

---

## Counting Elements

### [FrogRiverOne](https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/)

문제에서 요구하는 시간복잡도 O(N)

X값을 통해 채워져야 할 모든 숫자 값을 미리 배열에 담아놓고, 숫자가 나올 때마다 count를 해서, X값과 같은 값이 나오면 리턴해주고 끝까지 나오지 않는다면 -1

### [MissingInteger](https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/) / [PermCheck](https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/)

앞선 문제들과 동일한 패턴으로 풀 수 있는 문제이다.

### * [MaxCounters](https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/)

앞 문제들과 비슷하지만, 조금 더 복잡한 문제이다.

숫자들에 대해서 재평가가 필요할 때까지 평가를 미뤄두고, 재평가가 되어야 할 때 미리 저장해놓은 값과 비교하여 평가해야 한다
