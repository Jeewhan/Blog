---
layout: post
title: "The Real TDD"
date: 2018-10-18
tags: [TDD]
---

# The Real TDD
테스트 하기 쉬운 코드란?
- 순수함수와 같이, 동일 인풋에 동일 아웃풋 (데이터베이스를 조회해야 한다면 항상 같은 값을 리턴받을 것이라 기대하기 힘들 것)
  - Deterministic
- 외부상태를 변경하지 않는 코드
  - No side effects

- 유효성 검사
  - 	TDD 맛보기
    - Arrange, Act, Assert
    - 테스트를 만족하는 만큼만 구현하라
      - 부가적 코드들은 테스트 커버리지에 포함되지 않을 것
      - 점진적 구현의 효과도 상실
- 등록된 좌석 수를 디비에서 불러오기
  - 테스트하기 힘듬
  - 테스트하기 쉬운 코드와 어려운 코드를 분리하자
    - 간단한 연산을 테스트하기 위해 테스트 데이터 필요
    - 녹색과 빨간색을 분리하자 (안 그러면 녹색도 테스트하기 어려운 상황)
    - 디비에서 받아와야 하는 정보는 파라미터로 분리하거나 프로퍼티를 참조
  - 두 부류의 코드는 어디에서 만나야 하나?
    - 테스트하기 어려운 코드를 호출해서 사용해야 한다면 호출하는 코드도 테스트하기 어려울 것
    - 그러니 분리해서 최대한 가장자리에서 만나도록 하자 (테스트하기 어려운 여파가 최대한 덜 미치도록)
    - 예외 : 로깅, 퍼사드
  - 두 부류가 만나는 가장자리는 어떻게 테스트하나?
    - 수동테스트
      - 자동화테스트가 불필요할 정도로 간단한 경우
    - 자동테스트
      - 작성된 코드 사용을 강제할 수 있나?
        - 실제 클래스 대신 목 사용을 위해 이음새(Seam)가 필요
          - 인터페이스
          - 추상클래스
          - 보철메소드(?)
        - 목을 만들고 생성자에게 넘겨주고, 메소드 내에서 입력받은 인풋을 프로퍼티에 할당하도록 하고 그것을 메소드 실행 후에 assert로 검증
        - 목 사용으로 작성된 코드 사용을 강제할 수 있다
        - 하지만 생각해볼 포인트
          - 목 사용은 행위 검증
            - 행위가 호출되었는가
            - 불필요한 추상화 유발 가능성
            - 구현되지 않은 코드에 의존 가능
            - 아웃사이드인 기법
          - 목 사용하지 않는 것은 상태 검증
            - 결과값이 무엇인가
            - 불필요한 추상화 필요없음
            - 구현된 코드에만 의존
            - 인사이드아웃 기법
          - 목 사용의 문제점
            - 목을 남발할 가능성이 크다
            - 적정 수의 목 사용에 대한 답을 찾기 어렵다
            - 상태 검증으로 돌아가보자
          - 상태검증 문제 극복 방안
            - 사후 테스트를 하자
            - 구현된 코드를 사용하지 않고 굳이 어려운 길을 택할 필요가 없다
            - 목 사용도 비용이다
- 요청 좌석 수가 가능한지 판단
- 등록 정보 저장
  - 테스트하기 힘듬
- HTTP response

  두 부류의 코드를 분리해서 각각 테스트
  가장자리에서 맞물려 돌아가는 코드는 주로 수동테스트
  jwchung.github.io/testing-oh-my
  테스트 코드가 단순하기에 테스트 코드에 대한 테스트 코드를 작성하지 않듯이 단순하고 실수할 가능성이 낮은 부분에 대해 많은 비용을 들이려하지 않는다
  두 부류 코드를 섞어 넣고 테스트가 어렵다고 포기하지 마세요

  프라이빗 메소드는 어떻게 테스트?
- 테스트 대상 코드와 테스트 코드의 접촉 면적은 작을수록 좋습니다
  - 한 가지 메소드를 건들여서 가는게 좋습니다
  - 어떤 것은 퍼블릭 메소드로 할 것인가?

    레거시 코드에 대해서는 어떻게 하는가?
- 목업이 필요할 상황
- 레거시 코드와 결합도를 낮춰라
- 새로 생성된 코드에 테스트를 가할 것
- 케릭터라이제이션 테스트
  - 요구사항만 적어놓고 테스트
  - 테스트 안전망을 두고 리팩토링

    ---

    의식적인 연습으로 TDD, 리팩토링 연습하기

    왜 해야 하는지 왜 중요한지는 알고 있다는 가정하에 시작

    비중 : TDD < 리팩토링

    리팩토링을 이야기하는 것도 TDD에 관련된 이야기일 수 밖에 없음

    의식적인 연습이란?
    의식적인 연습으로 TDD, 리팩토링 연습 과정

    연습을 많이 한다고 잘 할 수 있는가?

    테스트하기 쉬운 코드와 어려운 코드를 보는 눈
    테스트하기 어려운 코드를 테스트하기 쉬운 코드로 설계하는 감

    많은 수련과 연습이 필요하다

    효과적으로 연습하려면?

    1만 시간의 재발견
    아마추어와 프로의 결정적 차이
- 목적 의식 있는 연습에 얼마나 많은 시간을 투자하는가?
- 7원칙
  - 컴포트존 벗어나기, 현재 능력보다 살짝 넘어가는 작업 지속적 시도
  - 명확하고 구체적인 목표
  - 피드백과 피드백에 따른 행동 변경을 수반
  - 기존 습득한 기술의 특정 부분을 집중적으로 개선하고 수정하는 과정 (한 번에 너무 여러 가지를 개선하려고 하지 말 것)

    의식적인 연습을 통한 효과적 개선

    단위 테스트 연습
- TDD보다 단위 테스트부터 연습하라
- 내가 사용하고 있는 API 사용법을 익히기 위한 학습 테스트부터 시작, 인풋과 아웃풋이 명확한 유틸성 메소드에 대한 연습
- 의도하는데로 잘 동작하는가?

  알고리즘을 학습한다면 알고리즘 구현에 대한 검증을 단위 테스트로 한다, 인풋 아웃풋이 명확해서 테스트하기 수월

  TDD 연습

  지켜야 할 원칙 : 회사 프로젝트에 연습하지 말고 토이 프로젝트를 활용해 연습하자
  프로덕션 코드는 도입하기가 어렵기 때문에 처음부터 시도하기엔 어려울 것

  어떤 인풋이 들어오면 어떤 아웃풋이 나올지를 미리 정의하고 시작해야 감이 잡힐 것

  테스트 fails, 테스트 passes 까지만 연습해보자

  테스트 코드를 먼저 만드는 것만해도 쉽지 않을 것

  난이도가 낮거나 자신에게 익숙한 문제로 시자가는 것을 추천

  리팩토링 연습

  메소드 분리
- 모든 프로그래머가 갖춰야 할 기본 역량
- 한 메소드에 오직 한 단계의 들여쓰기만 한다, 그 이상은 메소드로 분리
- else를 쓰지 않는다
- 한 가지 일만 해도록 하기
  - 섬은 스트링을 인트로 바꾸는 과정도 포함하고 있다
- 로컬 변수가 정말 필요한가?
- 컴포즈 메소드 패턴 (동등한 수준의 메소드로 분리)
  - 연습할 때는 극단적으로 해야 느끼는 것과 인사이트가 생겨난다

    한 번에 한 가지 명확하고 구체적인 목표를 가지고 연습하라, 한 번이 모든 원칙을 지키면서 리팩토링을 하려고 하면 너무 어렵다, 여유가 없으면 창의적일 수 없음
    메소드 라인 수 제한을 15 -> 10 -> 8 라인
- 설계에 대한 인사이트가 생긴다

  클래스 분리
- 모든 원시값과 문자열을 포장한다(클래스로 추출하라)
  - Validate이 보장된 클래스
- 일급 콜렉션을 사용
- 3개 이상의 인스턴스 메소드가 있는 클래스를 쓰지 않는다
  - 객체 설계 연습을 정말 많이 하게 되어요
  - 정량적인 연습을 계속 해보세요

    토이 프로젝트 난이도 높이기
- 점진적으로 요구사항이 높은 프로그램
  - 게임
  - 의존관계가 없는 것
  - 약간은 복잡한 로직이 있는 프로그램
  - 로또
  - 사다리 타기
  - 볼링게임 점수판
  - 체스게임
  - 지뢰첮기

    의존 관계 추가를 통한 난이도 높이기
- 의존 관계가 필요한 프로젝트
- 이때 필요한 역량은 설계 역량, 테스트 하기 쉬운 코드와 어려운 코드를 분리하는 역량

  한 단계 더 나아간 연습
- 컴파일 에러 최소화
- ATDD 기반으로 응용 애플리케이션 개발
- 레거시 애플리케이션에 테스트 코드 추가해 리팩토링하기
  - 갈수록 유지보수역량이 뛰어난 사람이 필요할 것이다

    구체적인 목표 연습 찾기
- 소트웍스 앤솔러지
  - 객체지향 생활체조 원칙
- 클린코드
  - 메소드 인수 개수 줄이기(2개 이하)
  - 클래스 크기를 최대한 작게 만들어서 가독성을 확보

    여유, 같은 과제를 반복적으로 구현할 수 있는 인내력, 꾸준히 도전할 수 있는 용기

    컴포트존 극복 노하우
- 경력이 쌓일수록 어렵다
- 삶에 여유와 에너지가 있어야 한다
- 남들이 하는 것을 다 하면서 성장하긴 어렵다, 일정 시간 몰입의 시간이 필요하다

  테스트 코드를 빡빡하게 짜놓을수록 요구사항의 변경시에 발목을 잡는데 노하우가 있는가?
- 요구사항 변경이 문제가 아니라 설계를 잘못했기에 테스트 코드의 변화가 많아진 것이다
- 나중에 개선할 수 있는 타이밍이라는 것은 오지 않는다

  ---

  Test driven development for code quality

  Overview of TDD
  The three rules of TDD
  TDD 이점
- 테스트 자동화의 장점
  - 개발 생산성 향상
    - 보통 테스트를 위한 오버헤드와 실제 구현에 드는 리소스를 1:1로 본다
    - 이펙티브 유닛 테스팅: 어 가이드 포 자바 디벨로퍼스
- 테스트 우선의 이점
  - 코드 품질 향상

    Think more about TDD

    코드 퀄리티 : Titanic diemma / jonathan bloom seen versus the unseen

    인터널 퀄리티 + 익스터널 퀄리티

    The seven axes of code quality from sonarcube

    Success with TDD

    ---

    테스트 시작하기

    테스트를 할 때는 프로덕션 코드는 건들이지 않는다
    리팩토링할 때는 테스트 코드는 수정하지 않는다

    not.toThrowError

    테스트가 단언하고 있는 내용이 사용자에게 중요한 가치를 주는 것인가?
    비즈니스와 관련된 버그인가?
    유지해서 얻는 이득보다 관리 비용이 더 큰 테스트는 아닌가?
    중 하나라도 해당하면 테스트하지 않음

    DOM 구조는 변화가 자주 있기 때문에 해당 사항을 고려한 테스트 코드를 짠다

    고민사항
- 픽스쳐 관리
- 함수로 계속 분리하는게 옳은 방식인가?
  - 추상화 수준이 낮아서 클라이언트에서 구체적인 내용을 알아야만 사용할 수 있는 것
  - 높은 응집, 낮은 결합 중 낮은 결합만 달성한 것

    irinso93@gmail.com

    ---

    테스트 코드는 프로젝트 코드가 사용되는 최초의 장소이며 고객이다

    모든 역사는 테스트 코드부터 시작된다

    숨겨진 본질
  - 낮은 추상화
  - 들쭉날쭉한 추상화
  - 끊어진 논리
  - 알 수 없는 의도
    욕심쟁이
  - 테스트가 실패하는 이유는 오직 단 하나여야 함
  - 하나의 테스트는 오직 한 가지만 검사해야 한다(SRP)
    인지능력의 과부화
  - 흩어진 코드와 데이터
  - 매직넘버
    깨지기 쉬운 것들
  - 높은 결합
  - 낮은 응집

    테스트를 이해하려면 그것의 환경을 이해해야 한다

    추상이란?
    문맥 위에서 오직 관심 있는 것들에 대해서만 집중하여 명확하게 하는 것

    테스트 코드의 의도가 명시적이 될 수 있도록 프로덕션 코드를 개선해나간다

    테스트 코드도 프로덕션 코드의 일부라고 바라보자

    테스트는 과정 수련 스승 거울 제품이다
    억지로 먼저 하지 마라, 건강하게 하라, 두려워하지 마라, 즐거워해라

    테스트가 우리를 가르쳐줘요

    테스트 코드를 리팩토링하고 피쳐를 추가할 여유가 없다면, 격리를 시켜서 내가 추가해야 할 코드의 사이즈를 줄여놓고 그 부분에 대해서만 진행을 한다

    ---

    사이언스 vs 엔지니어링 짤방

    엔지니어링 : 과학과 예산 간의 균형점

    중요한 것은 목표 달성이지, How가 중요하진 않을 수 있다

    과학자가 아니기에 TDD가 문제 해결에 도움이 되면 하고, 아니면 안 한다

    준비가 되지 않았다면 TDD가 아닌 방식으로 먼저 목표를 달성하고, 그 이후에 준비가 되가는만큼 도입해야 한다

    우리가 보호해야 하는 것 = 도메인

    제어할 수 없는 외부 세계를 다루려고 하지 않는다
- 실세계
- 인프라
- 외부 서비스
- 레거시

  낮은 결합, 높은 응집, 도메인 모델 보호

  설계를 테스트하라
  코드가 이루려는 가치를 테스트하라
- Stub 간접적인 입력 spy 간접적인 출력
- 위를 사용해야 하는 것은 구체적인 구현을 알아야 하는 테스트일 가능성이 높다

  정보 숨김 information hiding
- 어려운 설계 결정과 변경될 가능성이 높은 설계 결정들을 다른 모듈로부터 숨기는 것

  테스트 코드가 구현을 아는 것이 아니라 인터페이스를 테스트해야 한다

  어디까지가 인터페이스고 임플리테이션인가?

  레거시와 함께 살기

  어댑터 레이어를 통해 새로 작성하는 코드는 깨끗함을 유지, 해당 레이어는 테스트하지 않고 매뉴얼 테스트로도 테스트 가능하도록 단순하게 짠다

  점진
  반복
  Fail-Fast

  가설
  실험
  검증

  계획
  실행
  평가

  보통은 바로 실험이나 실행만 한다

  팀 내 목표와 지식에 대한 공유 문화가 매우 중요

  스프링과 도메인 모델이 강결합되어있는 것 아닌가, 이러면 도메인 모델이 보호받지 못한다

  도메인 모델, 중요한 코드일수록 플랫폼에서 독립적이어야 한다

  플랫폼 -> 모듈 -> 서비스 -> 비즈니스 로직

  View, View Model, Model

  사용자에게 어떤 가치를 전달할 것인가?
  두루뭉실하게 해서는 안 된다

  화이트보드를 통해 설계를 하는 것을 통해 목표와 목적을 공유할 수 있습니다

  목적 달성을 위해선 시스템에 어떤 변경이 필요한가?

  소프트웨어 변경은 어떤 세부 작업들이 있는가?
  각 작업들은 어떤 순서로 진행되어야 하는가?
  각 작업들은 누가 담당하는가?

  ATDD + TDD
  ATDD Red -> unit test red -> green -> refactor -> ATDD green

  이 작업에는 어떤 코드 변경(커밋)이 필요한가?

  작업을 구체적으로 설계하고 실제로 내가 했을 때와의 간극을 끊임없이 검증해서 내가 사전적으로 놓친 것을 파악해야 할 것

  그린 단계에서는 방금 작성한 코드 뿐 아니라 모든 테스트가 통과해야만 한다

  레드 단계의 에러 메시지를 살피지 않으면 테스트가 완성되지 않은 상태에서 그린으로 넘어가려고 할 수 있으니 주의할 것

  피드백
- 단위 테스팅
- 코드 리뷰
- 기능 테스킹
- 수동 테스팅
- 사용자 반응 수집

  코딩만 페어 프로그래밍을 하는 것이 아니라 테스크를 처리하는 과정까지 모두 페어링을 하였음

  유저 스토리를 비즈니스팀에서 러프하게 주면, 화이트보드에 그림을 그려보면서 검증, 초기 분석을 가지고 목록화, 어싸인되지 않은 유저스토리를 가져간다, 분석해서 어떤 코드를 작성해야하는지 판단하여 기재하여 리뷰를 요청하고, 테스크를 혼자 또는 나누어 진행할 수 있게 분배, 분배 후 페어링 또는 개별 분석을 통해 진행

  통합 테스트
  단위 테스트만으로는 불안감이 해소되지 않는다
  단위 테스트는 다 성공하는데 기능 테스트는 깨지는 때
  조합이 잘 되었는지 확인이 필요
  외부 서비스 같은 경우에는 페이크 서비스를 만들어서 잘 결합하는지 확인

  ---

  패널토크

  TDD가 왜 더 나은가? 어떻게 납득시킬 수 있는가?

  수많은 방법론 중에 왜 TDD인가?
- 테스트 코드를 짜면 프로덕션 코드에 대해 애정이 생기고 섬세하게 다루게 된다
- 가장 빠른 피드백을 준다

  프로그램의 본질은 구현체인데, 본질적 가치가 아닌 테스트나 리팩토링 등을 납득시킬 수 있는가?
- 굉장히 외롭습니다, 퀄리티를 위해 테스트를 한다, 설계적인 관점에 이점을 준다, 프로덕션에 영향을 주는 방법이다, 의사가 멸균을 하듯이 자연스럽게 이루어져야 하는 과정이다
- 주니어 개발자라면 다른 이를 설득하지 말고 내 만족을 위해서 하세요 그런데 내가 만들어놓은 코드에 대해 타인이 궁금해하면 전파하면 된다고 생각합니다, 전파에 너무 집착하지 마세요, 의사결정자가 되었을 때 가치있는 소프트웨어를 만드는데 필요하다는 확신이 들면 도입하면 좋겠어요
- 피드백을 빠르게 받는게 직무탈진율을 낮춘다, 삶의 퀄리티를 높여줍니다, TDD가 어디서부터 생긴 것인가? 애자일에서 발생한 것, 애자일한 환경이 갖춰졌을 때 TDD가 중요할 수 있다, 애자일에서는 개발을 사회적 활동으로 봅니다, 어떻게 하면 같이 할 수 있을까를 고민해봐야 합니다, 애자일은 모든 것이 모호한 상황에서 시도하는 곳이기에 다 준비되고 시작할 때 한다는 것은 애자일하지 않은 것일 수 있다, 주니어일 때 남들과 TDD를 같이 하기 수월할 수 있다
- 팀원들이 문제를 계속해서 끌어내도록 환경을 만들어서 팀원들로부터 짝 프로그래밍 등을 하자고 제안하도록 만든다, 팀장이 아닌 팀원이 드라이빙하도록 해서 하나씩 변화를 만들어간다, 팀원일 때는 변화를 만들어내기 위한 잽을 던지는 근육을 만들어야 시니어가 되었을 때 변화를 도입할 수 있다고 생각합니다
- 애자일을 도입할 때 애자일하게 도입하지 않는 경우가 많습니다, 마찬가지로 TDD도 점진적으로 도입시킬 수 있도록 작게 나누어서 도입시키고, TDD는 테스트의 순서가 대단히 중요한데 작지만 에센스한 것을 선택해야 합니다, 작은 것을 하되 에센스가 무엇인지 찾아야 합니다, 동료 개발자들의 문제 의식일 수도 있는 등 작지만 중요한게 무엇일까에 대한 생각을 해보는 것이 중요할 것 같습니다

  코드 커버리지를 어떤 기준으로?
- 매트릭스 자체에 집중하면 원래 얻고자 하는 것을 잃는 경우가 많습니다, 테스트 품질 자체도 대단히 중요합니다, 지표가 정해지면 그 지표만을 위한 테스트 케이스들이 만들어질테니 좋지 않다고 봅니다, 쉽지 않지만 테스트 커버리지에 집착하지 않는게 중요하고 실제 프로덕션 코드에 대한 이해를 높인다는 관점으로 접근하면 좋겠습니다, TDD 자체에 집착하지 말고 새로운 문제 등일 때 아직 명확하지 않을 때 조건과 인풋 아웃풋을 다듬어가면서 가야 할 때는 TDD에게 문제 해결방안을 얻어가면 좋겠습니다

  신입이 TDD 공부할 때 추천 콘텐츠
- 페어 프로그래밍 후 혼자 연습, 정진욱님 블로그 정주행
- 아트 오브 유닛 테스팅 -> XUnit patterns(Arrange가 대단히 어려운데, 테스트에서 일어나는 모든 상황이 정리되어있습니다, 케이스를 선택할 수 있었습니다) -> goos
- 테스트 주도 개발, 리팩토링
- 유튜브에 리팩토링이나 TDD 관련 카타 라고 검색하면 굉장히 많이 나옵니다
- TDD는 종합예술같은 것이에요, 모든 것들이 결집되어 나타나는 산출물이기 때문에 한 번에 얻어내긴 어려우실 거에요, 테스트가 주는 이점을 많이 느끼고 그것을 바탕으로 성장하는게 필요합니다

  도메인 모델과 스프링의 접점을 왜 줄여야 하는가?
- 새로 나오는 좋은 도구와 플랫폼이 나와도 옮겨갈 수 없다, 중요한 도메인 모델이 덜 중요한 플랫폼에 종속하도록 하는 것은 좋은 결정이 아니라고 생각합니다
- 스프링이나 데이터베이스 기반이 아니라 순수 언어 기반으로 프로그래밍 연습을 하고 변경을 최소화하면서 외부 세계와의 접점을 늘려가세요, 많은 프로그래머들이 프레임워크 기반으로 연습을 하다보니까 순수한 언어 기반 연습을 잘 안하게 되는데 그것을 하고 나서 프레임워크로 가보면 또 다른 인사이트를 느낄 수 있습니다
- 도메인 모델, DTO, 퍼시스턴트 오브젝트 등으로 모두 분리할 수 있는가, 복잡하지 않을 때는 공유하는게 이점이 있을 것
- 도메인 모델에 로직이 있어야 하는데 스프링 영역으로 내려오면 테스트가 힘들어집니다, 객체지향적 사고를 해야 합니다
- DDD에서 도메인과 기술을 구분하는 것에는 동의하지만, 프레임워크가 도메인에 침투되는 것은 어쩔 수 없지만 얼마나 최소화하느냐 그리고 우리 상황에 얼마나 맞게 할 수 있느냐가 중요합니다, 무조건적인 분리를 이루려고 하면 또 잃는게 많을 수 있습니다
- 자바가 아닌 스프링으로 시작하는 것에 대한 저항감을 가지고 있는 것이 주니어 입장에서 좋겠습니다

  레거시에 도입
- 그냥 두는 것이 방법이라고 생각합니다, 비즈니스적으로 이유가 없다면, 있을 때도 변경을 최소화하는게 필요하다고 생각합니다, 레거시에는 하지 않고 새로운 것을 도입할 때 하는게 좋다고 생각합니다, 최소한 변경하는 것은 또 디자인의 문제입니다
- 레거시가 방대한데 우리는 그 곳에서 또 살아야 합니다, 방치할 수는 없습니다, 팀 문화가 괜찮다면 점진적으로 리팩토링해나가야죠, 전체적으로 문화를 만들어야만 전체적인 리팩토링을 이룰 수 있다고 생각합니다
- 레거시와 친하게 지내세요, 착한 레거시도 있어요, 잘 나눠줘야되어요, 나쁜 레거시는 잘 인정해주어야 되어요, 그와 소통하는 인터페이스만 잘 만들어주면 되는 거에요, 비즈니스를 위해 일을 해야 합니다, 잘 일하고 있는 착한 레거시를 가만히 둡시다
- 개발자들은 ROI를 항상 생각해야 합니다, 그렇지 않으면 무의미한 것에 매몰될 수 있습니다, 3000라인 17중첩 일주일에 한 두 번 수정하면서 if문 추가 대마왕 7천라인 얘는 3천라인, 소마왕 해결하고 싶은데 도와줄 수 있냐, 2~3시간 만에 50라인으로 줄였어요, 모두가 공감하고 있었고 그래서 수정했기 때문에 계속 혜택을 누리게 되면 동참하게 되어요, 그냥 레거시를 다 적으로 생각하지 말고, 모두 ROI를 기반으로 판단하시면 항상 복리효과를 누리실 수 있을 것이라 생각합니다--
