<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>실용적인 함수형 자바스크립트 Intro | The Pragmatic Programmer</title><link rel="stylesheet" href="/libs/spoqa-han-sans-kr/css/SpoqaHanSans-kr.css"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://JeewhanR.github.io/2018/07/09/Functional-Programming-Intro/"/>
<meta name="description" content="자바스크립트로 알아보는 함수형 프로그래밍함수형 프로그래밍 개요함수형 프로그래밍 정의, 순수함수성공적인 프로그래밍이란?  좋은 프로그램을 만드는 일 사용성, 성능, 확장성, 기획 변경에 대한 대응력이 좋은 것   위 사항들을 효율적이고 생산적으로…">
<meta name="keywords" content="FP">
<meta property="og:type" content="article">
<meta property="og:title" content="실용적인 함수형 자바스크립트 Intro">
<meta property="og:url" content="https://JeewhanR.github.io/2018/07/09/Functional-Programming-Intro/">
<meta property="og:site_name" content="The Pragmatic Programmer">
<meta property="og:description" content="자바스크립트로 알아보는 함수형 프로그래밍함수형 프로그래밍 개요함수형 프로그래밍 정의, 순수함수성공적인 프로그래밍이란?  좋은 프로그램을 만드는 일 사용성, 성능, 확장성, 기획 변경에 대한 대응력이 좋은 것   위 사항들을 효율적이고 생산적으로…">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://jeewhanr.github.io/images/hollywood.jpg">
<meta property="og:updated_time" content="2018-07-08T15:46:56.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="실용적인 함수형 자바스크립트 Intro">
<meta name="twitter:description" content="자바스크립트로 알아보는 함수형 프로그래밍함수형 프로그래밍 개요함수형 프로그래밍 정의, 순수함수성공적인 프로그래밍이란?  좋은 프로그램을 만드는 일 사용성, 성능, 확장성, 기획 변경에 대한 대응력이 좋은 것   위 사항들을 효율적이고 생산적으로…">
<meta name="twitter:image" content="https://jeewhanr.github.io/images/hollywood.jpg"><meta property="article:author" content="Jeewhan"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-07-09 00:00:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="Jeewhan"><link rel="icon" href="/images/hollywood.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="The Pragmatic Programmer"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/hollywood.png" alt="The Pragmatic Programmer"><span class="menu__item__link--brand__label">The Pragmatic Programmer</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">실용적인 함수형 자바스크립트 Intro</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-07-08T15:00:00.000Z" itemprop="datePublished">2018-07-09 00:00:00</time></div><hr><div class="article__contents"><h1 id="자바스크립트로-알아보는-함수형-프로그래밍"><a href="#자바스크립트로-알아보는-함수형-프로그래밍" class="headerlink" title="자바스크립트로 알아보는 함수형 프로그래밍"></a>자바스크립트로 알아보는 함수형 프로그래밍</h1><h2 id="함수형-프로그래밍-개요"><a href="#함수형-프로그래밍-개요" class="headerlink" title="함수형 프로그래밍 개요"></a>함수형 프로그래밍 개요</h2><h3 id="함수형-프로그래밍-정의-순수함수"><a href="#함수형-프로그래밍-정의-순수함수" class="headerlink" title="함수형 프로그래밍 정의, 순수함수"></a>함수형 프로그래밍 정의, 순수함수</h3><p>성공적인 프로그래밍이란?</p>
<ul>
<li>좋은 프로그램을 만드는 일<ul>
<li>사용성, 성능, 확장성, 기획 변경에 대한 대응력이 좋은 것</li>
</ul>
</li>
<li>위 사항들을 효율적이고 생산적으로 이루어지는 것이 성공적인 프로그래밍</li>
</ul>
<p>함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수효과를 미워하고 조합성을 강조하는 프로그래밍 패러다임</p>
<ul>
<li>부수효과를 미워한다 =&gt; 순수함수를 만든다<ul>
<li>순수함수란?<ul>
<li>부수효과가 없음<ul>
<li>외부의 대상에 영향을 끼치지 않음</li>
<li>인자를 변경하지 않음</li>
<li>리턴 값 외에는 외부와 소통하는 것이 없음</li>
</ul>
</li>
<li>수학적 함수</li>
<li>인자가 동일하면 동일한 결과를 반환</li>
<li>상수적 자유변수를 참조할 수 없다는 것은 아님</li>
</ul>
</li>
<li>오류는 적고 안정성은 높다</li>
</ul>
</li>
</ul>
<ul>
<li>조합성을 강조한다 =&gt; 모듈화 수준을 높인다<ul>
<li>순수함수의 조합으로 프로그래밍 진행</li>
<li>모듈화 수준이 높다 = 생산성을 높인다<ul>
<li>모듈화 수준이 높다는 것은 성공적인 프로그래밍의 척도</li>
<li>재사용성이 높고 팀웍도 좋고 기획 변경에 대한 대응력이 높음</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>순수함수란?</p>
<ul>
<li>인자가 동일하면 동일한 결과를 반환<ul>
<li>평가 시점이 중요하지 않음<ul>
<li>평가시점을 개발자가 다룰 수 있음<ul>
<li>다양한 로직과 이점을 취할 수 있음</li>
</ul>
</li>
<li>항상 동일한 결과를 리턴할 것이기에 안전하고 다루기 쉬운 함수이고 따라서 조합성을 강조시킬 수 있음<ul>
<li>다른 함수의 인자로 넘겨주거나, 전혀 다른 곳에서 함수를 평가시켜도 항상 동일한 결과를 리턴</li>
</ul>
</li>
<li>그렇지 않은 함수들은 평가 시점에 따라 결과가 달라지게 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>부수효과가 없음<ul>
<li>리턴 외의 출력이 없음</li>
<li>인자를 변경하지 않음<ul>
<li>원하는 부분이 변형된 새로운 값을 만들어 리턴하는 방식으로 진행</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="일급함수-add-maker-함수로-함수-실행하기"><a href="#일급함수-add-maker-함수로-함수-실행하기" class="headerlink" title="일급함수, add_maker, 함수로 함수 실행하기"></a>일급함수, add_maker, 함수로 함수 실행하기</h3><p>일급함수</p>
<ul>
<li>함수를 값으로 다룰 수 있음<ul>
<li>변수에 담을 수 있음</li>
<li>인자로 넘겨줄 수 있음</li>
</ul>
</li>
<li>런타임에서 언제든 정의할 수 있다</li>
<li>원할 때 평가할 수 있다<ul>
<li>다른 함수가 실행하도록 할 수 있음</li>
</ul>
</li>
</ul>
<p>일급함수 개념과 순수함수 특징을 이용해서 함수의 조합성을 높여나가는 것이 함수형 프로그래밍</p>
<p>평가 시점에서 자유로운 순수함수들을 만들고, 순수함수들을 값으로 가지고 다니면서 적절한 시점마다 평가를 하는 다양한 로직을 만들어나가는 것이 함수형 프로그래밍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_maker</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = add_maker(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( add10(<span class="number">20</span>) ); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>순수함수, 일급함수와 클로저가 함께 사용되는 예제</p>
<ul>
<li>내부함수는 자신의 입장에선 a를 변경하지 않고, 늘 같은 a를 바라보고 있는 순수함수</li>
<li>내부함수는 a를 참조하는 클로저</li>
<li>add_maker(10)의 결과를 add10에 담을 수 있는 것은 일급함수의 성질</li>
</ul>
<p>내 나름대로의 클로저 정의</p>
<ul>
<li>자유변수를 참조하는 함수</li>
<li>스코프</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params">f1, f2, f3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f3(f1() + f2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  f4(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * a; &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>함수가 어떤 함수들을 인자로 받아서 그 함수가 원하는 로직대로 원하는 시점에 원하는 인자를 적용하면서 프로그램을 완성해나가는 것이 함수형 프로그래밍</p>
<p>순수함수들을 조합하고, 최종적으로 어떠한 결과를 만들어가는 것</p>
<p>순수함수를 만들고 조합하는 평가시점과 방법, 어떤 로직 사이에서 평가를 할 것인지 결정하면서 큰 로직을 구성</p>
<p>비동기, 동시성을 확보할 수 있도록 원하는 시점까지 값으로 함수를 가지고 다니다가 원하는 시점 또는 필요한 부분에서 받아둔 함수를 여러 번 실행하는 등의 로직을 구현 가능</p>
<h3 id="요즘-개발-이야기-함수형-프로그래밍-정의"><a href="#요즘-개발-이야기-함수형-프로그래밍-정의" class="headerlink" title="요즘 개발 이야기, 함수형 프로그래밍 정의"></a>요즘 개발 이야기, 함수형 프로그래밍 정의</h3><p>요즘 개발 이야기</p>
<ul>
<li>재미/실시간성 : 라이브 방송, 실시간 댓글, 협업, 메신저</li>
<li>독창성/완성도 : 애니메이션, 무한스크롤, Masonry</li>
<li>더 많아져야하는 동시성 : 비동기 I/O, CSP, Actor, STM</li>
<li>더 빨라야하는 반응성/고가용성 : ELB, Auto Scailing, OTP Supervisor</li>
<li>대용량/정확성/병렬성 : MapReduce, Clojure Reducers</li>
<li>복잡도/MSA/… : 많아지고 세밀해지는 도구들</li>
</ul>
<p>스멀스멀 다가오는 FP</p>
<ul>
<li>좋아지는 하드웨어 성능과 컴파일러, 함수형 프로그래밍 기술, 좋아지는 분산/리액티브 환경, 동시성 + 병렬성 관련 기술, 성공적인 적용 사례와 영향</li>
</ul>
<p>마이클 포거스</p>
<ul>
<li>함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고, 이러한 함수 개념을 가장 우선순위에 놓는다.</li>
<li>함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 데이터(객체) 기준</span></span><br><span class="line">duck.moveLeft();</span><br><span class="line">duck.moveRight();</span><br><span class="line">dog.moveLeft();</span><br><span class="line">dog.moveRight();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 기준</span></span><br><span class="line">moveLeft(dog);</span><br><span class="line">moveRight(duck);</span><br><span class="line">moveLeft(&#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br><span class="line">moveRight(dog);</span><br></pre></td></tr></table></figure>
<p>함수가 먼저 나오느냐, 객체가 먼저 나오느냐 (FP, OOP)</p>
<ul>
<li>객체지향에서는 데이터를 먼저 디자인하고, 그 데이터에 맞는 메소드를 만드는 방식으로 진행하고, 함수형은 함수를 만들고 함수에 맞게 데이터셋을 구성하는 방식으로 진행한다 (데이터의 형태를 함수를 사용할 수 있도록 디자인)</li>
</ul>
<p>왜? 보다는 어떻게!를 다루겠다고 하셨음, 어떻게를 알려면 어떻게 전환하는가? 전환해왔는가? 를 아는 것이 중요함</p>
<h2 id="함수형으로-전환하기"><a href="#함수형으로-전환하기" class="headerlink" title="함수형으로 전환하기"></a>함수형으로 전환하기</h2><h3 id="회원-목록-map-filter"><a href="#회원-목록-map-filter" class="headerlink" title="회원 목록, map, filter"></a>회원 목록, map, filter</h3><p>응용형 함수, 콜렉션을 다루는 함수</p>
<p>함수형 프로그래밍에서는 원래 있는 값을 직접 변경하지 않고 변형된 새로운 값을 리턴합니다</p>
<p>중복을 제거하거나 추상화할 때 함수를 이용해서 프로그래밍하는 것이 함수형 프로그래밍</p>
<p>조건을 인자로 올 함수에게 위임</p>
<p>응용형 함수, 응용형 프로그래밍, 적용형 프로그래밍</p>
<ul>
<li>함수가 함수를 받아서 원하는 시점에 인자를 적용하는 형식으로 프로그래밍</li>
</ul>
<p>고차함수</p>
<ul>
<li>함수를 받거나, 함수를 리턴하거나, 인자로 받은 함수를 실행</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempUsers = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].age &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    tempUsers.push(users[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tempUsers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로그래머가 _filter 함수를 호출할 때, 어떤 데이터가 넘어가는지와 처리하고자 하는 조건에 대해 인지하고 있기에 재활용성이 매우 높은 함수가 되었음</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// users -&gt; list로 일반화 가능</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_filter</span>(<span class="params">users, predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newList = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate(users[i])) &#123;</span><br><span class="line">      newList.push(users[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tempUsers.length; i++) &#123;</span><br><span class="line">  names.push(tempUsers[i].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list : 어떤 배열이든 무관, mapper : 어떤 데이터를 수집할지 위임</span></span><br><span class="line"><span class="comment">// 다형성이 높고, 데이터가 구체적으로 어떻게 생겼는지 보이지 않음 -&gt; 관심사의 분리</span></span><br><span class="line"><span class="comment">// mapper 예시 : user =&gt; user.name</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_map</span>(<span class="params">list, mapper</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newList = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    newList.push(mapper(list[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _map(</span><br><span class="line">    _filter(users, <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123; <span class="keyword">return</span> user.age &gt;= <span class="number">30</span>; &#125;),</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123; <span class="keyword">return</span> user.name; &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 현재 동일한 Loop를 두 번 도는 중복이 존재합니다</span></span><br></pre></td></tr></table></figure>
<p>함수형 프로그래밍에서는 대입문을 많이 사용하지 않음</p>
<p>값을 만들어놓고 문장을 내려가면서 변형해가는 것이 아니라, 함수를 통과해가면서 한 번에 값을 새롭게 만들어가는 방식으로 함수형 프로그래밍이 진행됨</p>
<p>대입문이 없으면 보다 간결한 코드를 만들 수 있습니다</p>
<h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop를 돌면서 적용할 로직에 대해선 인자에 올 함수에게 위임</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_each</span>(<span class="params">list, iterate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    iterate(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_map</span>(<span class="params">list, mapper</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newList = [];</span><br><span class="line">  </span><br><span class="line">  _each(list, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    newList.push(mapper(val));</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_filter</span>(<span class="params">list, predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newList = [];</span><br><span class="line">  </span><br><span class="line">  _each(list, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate(val)) newList.push(val);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>코드가 점점 간결해지고, 명령적인 코드가 숨고 선언적인 코드표현, 단순해지고 오류가 줄어들고 보다 정확하게 코딩을 하고 있다는 확신을 쉽게 느낄 수 있음</p>
<h3 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h3><p>이미 자바스크립트에는 map, filter와 같은 함수들이 구현되어있는데, 우리는 왜 또다시 구현했을까?</p>
<p>자바스크립트에 이미 있는 그것들은 함수가 아니라 메소드이다 (객체의 상태에 따라 결과가 달라지는)</p>
<p>해당 클래스의 인스턴스에서만 사용가능 (array-like에서는 사용불가) 다형성을 지원하기 어려움</p>
<p>함수가 기준이 되는 함수형 프로그래밍에서는 함수를 먼저 만들고 그 함수에 맞는 데이터를 구성하여 함수에게 전달하는 식으로 프로그래밍하므로 높은 다형성을 만들어내고 유용하고 실용적일 수 있게 된다</p>
<p>배열이 아니더라도 length property가 숫자이면 map이나 each 모두 사용가능하게 됨</p>
<p>함수가 먼저 나오는 프로그래밍 VS 데이터가 먼저 나오는 프로그래밍<br>(데이터가 먼저 나오는 프로그래밍은 데이터가 있어야만 메소드가 생길 수 있다, 그래서 객체지향에서는 평가의 순서가 대단히 중요해진다)</p>
<p>함수가 먼저 나오는 프로그래밍은 평가시점에 있어 훨씬 유연해질 수 있다 =&gt; 더 높은 조합성<br>(함수가 먼저 나오는 프로그래밍은 함수가 우선 먼저 홀로 존재하기 때문에 데이터가 없더라도 평가 시점이 상대적으로 훨씬 유연해진다)</p>
<p>응용형 함수의 장점</p>
<p>함수형 프로그래밍에서는 보조함수가 어떤 역할을 하느냐에 따라 굉장히 다양한 이름을 갖게 되는 점이 중요합니다</p>
<p>콜백함수는 어떤 일들을 수행한 뒤에 맨 끝에서 다시 돌려주는 함수만을 뜻함</p>
<p>predicate : 조건을 리턴하는 함수</p>
<p>iterate : Loop를 돌면서 반복적으로 실행되는 함수</p>
<p>mapper : 무엇과 무엇을 매핑하는 함수</p>
<p>각각의 역할에 맞게 보조함수를 지칭해줄 것, 그렇게 할 때 다양한 좋은 응용형 고차함수들을 만들어 낼 수 있을 것</p>
<p>내부 다형성</p>
<p>외부의 다형성 (array_like도 돌릴 수 있게 되는 것)은 _map과 같은 고차함수가 어떻게 구현되었는지에 따라 만들어지지만, 배열 안에 어떤 값이 담겨있든 수행할 수 있도록 만들어주는 내부의 다형성은 보조함수(predi, iter, mapper)가 만들어낸다</p>
<p>개발자가 함수에 넘겨줄 데이터에 대한 이해를 바탕으로 보조함수를 결정할 수 있고, 고차함수에서는 데이터에 대해 언급하는 코드 없이 보조함수에게 위임하기 때문에 데이터 형에 있어서 굉장히 자유롭고 다형성을 높이는데 유리합니다</p>
<h2 id="컬렉션-중심-프로그래밍"><a href="#컬렉션-중심-프로그래밍" class="headerlink" title="컬렉션 중심 프로그래밍"></a>컬렉션 중심 프로그래밍</h2><h2 id="자바스크립트에서의-지연-평가"><a href="#자바스크립트에서의-지연-평가" class="headerlink" title="자바스크립트에서의 지연 평가"></a>자바스크립트에서의 지연 평가</h2><h2 id="실전코드조각-1"><a href="#실전코드조각-1" class="headerlink" title="실전코드조각 1"></a>실전코드조각 1</h2><h2 id="실전코드조각-2"><a href="#실전코드조각-2" class="headerlink" title="실전코드조각 2"></a>실전코드조각 2</h2><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><hr>
<h2 id="특강"><a href="#특강" class="headerlink" title="특강"></a>특강</h2><ul>
<li>부수효과가 나쁜 것이 아니라, 결론에 해당함 (Just Side Effect, Not 부작용)<ul>
<li>다만 디테일하게 쫒아가면서 다루지 않으면, 에러를 유발하기가 매우 쉬움</li>
<li>부원인, 부작용</li>
<li>부수효과를 일으키는 대상을 리턴하도록 짜면 조합성을 높이는데 큰 도움이 됨</li>
</ul>
</li>
<li>참조 투명성</li>
<li>일급함수와 클로저가 함수형 프로그래밍을 지탱하는 두 축<ul>
<li>일급함수<ul>
<li>함수를 변수, 인자, 리턴, 평가(=실행)</li>
</ul>
</li>
<li>클로저<ul>
<li>값과 변수, 함수를 통칭해서 클로저라고 함</li>
<li>호출하여 할당함으로서 클로저가 됨</li>
<li>메모리에서 자유변수를 유지시켜야만 클로저</li>
<li>함수를 하나의 스택으로 보고, 자유변수에 대한 참조를 유지시키느냐 여부가 중요</li>
<li>클로저를 만들어두고 계속해서 사용하는 패턴이 함수형 프로그래밍에서 흔함</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>순수함수</p>
<p>부수효과</p>
<p>필수 부수효과</p>
<p>새로운 값을 리턴하는 순수함수</p>
<p>고차함수(함수를 값으로 다루는 함수)</p>
<ul>
<li><p>함수를 리턴해주는 함수</p>
</li>
<li><p>함수를 인자로 받아서 안에서 실행하는 함수 (응용형 프로그래밍)</p>
<ul>
<li>function repeat(count, fn) { var i = 0; while (count–) fn(i++); }</li>
<li>var i = -1; while (++i &lt; count) fn(i);</li>
</ul>
</li>
</ul>
<p>어떻게 동작하느냐(명령형 프로그래밍)가 아니라 이렇게 되도록 하는 것을 선언형 프로그래밍(함수형 프로그래밍 포함)</p>
<p>부수효과를 어떻게 다루느냐가 함수형 프로그래밍의 성향 (언어에 따라 부수효과를 모나드로 관리하기도 함)</p>
<p>브라우저 또는 DB를 조작해야 하므로 자바스크립트에서는 부수효과가 없는 프로그래밍은 불가능할 것 (로직 과정에선 없을 수 있음)</p>
<p>5종류 함수를 적절히 조합, 문보다는 함수(표현식)를 위주로 프로그래밍, 변수 사용을 줄이고 값을 변경하지 않는다, 꼭 필요한 부수 효과 함수를 제외하고는 부수 효과를 로직에 이용하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수형 프로그래밍</p>
<ul>
<li>결과를 리턴해주는 식으로 외부와 소통한다</li>
<li>기존 값을 수정하지 않고, 새로운 값을 만들어서 리턴한다</li>
<li>조건을 함수로 추상화하여 인자로 받는다<ul>
<li>predicate(products[i]) : 로직을 완전히 위임</li>
<li>while (++i &lt; l) predicate(list[i]) &amp;&amp; new_list.push(list[i]))</li>
</ul>
</li>
<li>추상화의 단위가 함수<ul>
<li>객체지향은 객체 또는 메소드 단위</li>
</ul>
</li>
<li>표현식만으로 코딩하는 습관</li>
<li>데이터가 먼저인 프로그래밍은 다형성이 낮을 수 밖에 없음, 특정 데이터에 종속됨<ul>
<li>함수형은 함수를 먼저 만들고 함수에 맞는 형태의 데이터를 전달</li>
<li>외부의 값에 대한 다형성을 높이고, 내부 값에 대한 다형성은 보조 함수로 커버</li>
</ul>
</li>
</ul>
<p>함수 이름은 자세히 써주고, 변수는 한 글자 수준으로 축약하곤 함, k key l length v value f func</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_all</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, l = list.length, memo = list[i++];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) memo = add(memo, list[i++]);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce란 순회하면서 보조함수로 축약하는 것</p>
<ul>
<li>reduce([1,2,3,4], add)</li>
<li>function add_all(list) { return reduce(list, add); }</li>
</ul>
<p>고차함수를 만들고 적용가능한 보조함수를 전달하여 새로운 값을 만들어가는 것</p>
<p>상수인 변수와 함수를 가지고 새로운 상수를 만들어냄</p>
<p>reduce도 클로저 위에 쌓여있음</p>
<p>순수함수이기에 내가 원하는 기능을 한다면 얼마든지 가져다써도 괜찮고, 필요한 경우에만 만들어가면서 쓰면 될 것</p>
<p>자바스크립트는 Array-Like에 지원하는 함수가 많다는 것이 조금 부족한 점 (엘릭서 등은 모든 데이터셋에 지원)</p>
<p>함수형 프로그래밍에서 사용하는 기본 함수들은 직접 만들어보는 것이 피가 되고 살이 됨</p>
<p>가능한 데이터가 함수 내에서 보이지 않을 정도로 추상화해볼 것</p>
<p>숫자들에서 숫자로 축약하는 것은 reduce로 충분하지만, 그것이 아니면 시작하는 외부 값을 지정해줄 수 있어야 함 (더 다형성이 높은 함수가 되기 위해서)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">list, fn, memo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, l = list.length, memo = memo === <span class="literal">undefined</span> ? list[i++] : memo;</span><br><span class="line">  <span class="comment">// while (i &lt; l) &#123; memo = fn(memo)&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>은닉은 도구이고 취향이지, 목적이 아니다</p>
<p>실용적인 클로져들을 만드는 것이 함수형 프로그래밍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pipe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reduce(fns, <span class="function"><span class="keyword">function</span>(<span class="params">arg, f</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(arg);</span><br><span class="line">    &#125;, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reduce(<span class="built_in">arguments</span>, )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calr</span>(<span class="params">arg, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>표현식만으로 코딩하면 라인이 없어서 어려운데, go를 통해 라인을 만들 수 있음</p>
<p>커링 : 함수의 인자를 부분적으로 적용</p>
<p>함수가 함수를 만들고, 함수가 다른 함수에 적용되는 함수 등을 만들어가는 함수형 프로그래밍</p>
<p>for, while은 코드의 모양이 익숙한 것이지, 코드의 로직이 익숙한 것이 아님</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = curryr(<span class="function">(<span class="params">list, predicate</span>) =&gt;</span> reduce(list, (new_list, val) =&gt; predicate(val) ? append(new_list, val) : new_list ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">list, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(val), list; <span class="comment">// 좌측이 실행된 뒤에 우측이 리턴됨</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수 + 파이프라인적 사고로 진행하는 것이 중요합니다</p>
<p>go가 reduce로 만들어진 함수</p>
<p>chaining은 monad의 일종이에요, chaing은 메소드를 바꿔가면서, curry는 하나의 함수로 도달하기 위해서 인자를 하나씩 전달해주다가 인자가 전부 차면 그때 실행하는 것 (실행을 미루기 위해 쓰임)</p>
<p>프론트엔드에서의 비동기 : 성능과 사용성, 브라우저 렌더링이 비동기와 대단히 연관되어있음 (네이티브처럼 만들 수 있음)</p>
<p>백엔드에서의 비동기 : 과거의 쓰레드를 사용했었는데 500개 이상은 어려웠는데 Node.js는 2만 개까지 처리 가능함, 쓰레드는 하나만 쓰고, 비동기적으로 함수를 동시다발적으로 실행하면 됨, 과거에 비해 스케일이 커지고 다이나믹해지다보니 비동기에 대한 니즈가 급증함</p>
<p>비동기 상황 잘 다루기</p>
<ul>
<li>리턴 값으로 소통하기</li>
<li>원하는 순서대로 함수 실행을 나열하는 법 연습</li>
<li>표현식 만으로 코딩하는 연습 =&gt; 꼬리 함수 호출 최적화</li>
<li>재귀 함수 연습</li>
</ul>
<p>기본기</p>
<ul>
<li>비동기와 무관하게 내가 원하는 로직을 일렬로 나열할 수 있도록 하는 것이 제어의 첫 걸음</li>
<li>비동기라는 것은 함수 단위로 일어납니다, 단 결국은 재귀로 돌아가는 것 (+ 추상화를 얼마나 더 하느냐)</li>
</ul>
<p>연속적으로 내가 원하는 함수를 나열하고, 원할 때 호출</p>
<p>reduce를 재귀 + 유명 함수를 이용하여 Promise 제어</p>
<p>표현식만 남긴다, 즉시 실행함수로 담으면 문이어도 함수로 만들 수 있음</p>
<p>프라미스 : 비동기의 결과가 값으로 다뤄질 수 있도록 함</p>
<p>go, pipe, map, filter</p>
<p>map, map (동시성)</p>
<p>console.time, console.timeEnd</p>
<p>비동기를 동기처럼 만든다 의 한 수 위가 둘을 적절히 다룬다</p>
<p>FP는 램은 많이 쓰되, CPU는 적게 쓰는 편</p>
<p>OOP와 FP는 대척점에 있지 않다, 랩을 잘 하는게 멋있는 것, 모두 현대 프로그래밍에서 필요함, DOM 조작은 모두 객체를 다뤄야 함, 프로그래밍 언어 자체보다 더 중요한 것은 멀티플 패러다임을 잘 이해하는 개발자가 되는 것, 그러면 적절한 도구를 필요할 때 쓸 수 있게 됨, 객체 지향이 없었다면 Promise가 있을 수 없었음, FP가 비동기를 지탱하는 기술임에도 함수 기법 자체는 가볍게 훑어지는 경향이 있는데 그것을 잘 다루면 더 나은 프로그래밍을 할 수 있음</p>
<p>네이밍 컨벤션에 카멜 케이스를 쓰지 않는 것도 함수형과 유관? =&gt; DB의 명칭과 통일</p>
<p>arguments는 this와 달리, 부원인이 아니라 매개변수와 동등하게 보시는지? =&gt; 외부에 변화를 주지 않는다면 부원인이 아니다</p>
<p>ES6는 학습자를 배려해서 의도적으로 배제? (rest parameter, Promise.all) =&gt; 그것이기도 하지만, Promise는 모든 로직을 비동기로 처리하기에 적절한 조합을 할 수 없음</p>
<p>_each의 가치를 언어에서 기본적으로 지원해주는 map, call, apply, Array.from에 대항하여 어떻게 내세울 수 있을지 (_go : method chaining) =&gt; forEach는 return 이 undefined라는 큰 차이가 존재하며, 리습 계열의 컨벤션은 언어에 부족한 점이 있다면 개발자가 보완하는 방향</p>
<p>언어에서 기본적으로 제공해주는 것에 비해, 로직 즉 탈언어적 요소 위주의 방향으로 코딩하는 것이 우선적인 지향점으로 더 좋을지 =&gt; 그게 실력향상에도 좋음</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/FP/">FP</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/avatar.jpg" alt="Jeewhan"><a class="article__author__link" title="About Jeewhan" rel="author">Jeewhan</a><p class="article__author__desc">Dev Blog</p><div class="article__author__socials"><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Jeewhan"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-07-08T15:46:56.661Z"><meta itemprop="articleBody" content="자바스크립트로 알아보는 함수형 프로그래밍함수형 프로그래밍 개요함수형 프로그래밍 정의, 순수함수성공적인 프로그래밍이란?

좋은 프로그램을 만드는 일
사용성, 성능, 확장성, 기획 변경에 대한 대응력이 좋은 것


위 사항들을 효율적이고 생산적으로 이루어지는 것이 성공적인 프로그래밍

함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수효과를 미워하고..."><meta itemprop="url" content="https://JeewhanR.github.io/2018/07/09/Functional-Programming-Intro/"><meta itemprop="mainEntityOfPage" content="https://JeewhanR.github.io/2018/07/09/Functional-Programming-Intro/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="The Pragmatic Programmer"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://JeewhanR.github.io/images/hollywood.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://JeewhanR.github.io/images/hollywood.jpg"><meta itemprop="url" content="https://JeewhanR.github.io/images/hollywood.jpg"><meta itemprop="width" content="800"><meta itemprop="height" content="800"></div></article></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/08/12/NodeJS-TextBook/">Node.js 교과서</a></li><li class="recent-posts__item"><a href="/2018/07/09/Functional-Programming-Intro/">실용적인 함수형 자바스크립트 Intro</a></li><li class="recent-posts__item"><a href="/2018/06/24/Awesome-Article1/">실용적인 아티클 1</a></li><li class="recent-posts__item"><a href="/2018/05/27/Ruby-Pickaxe-chapter3/">루비 곡괭이 3장 클래스, 객체, 변수</a></li><li class="recent-posts__item"><a href="/2018/05/13/Ruby-Pickaxe-chapter2/">루비 곡괭이 2장 Ruby.new</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/Algorithm/" style="font-size: 1.5rem;">Algorithm</a> <a href="/tags/Article/" style="font-size: 0.75rem;">Article</a> <a href="/tags/CtCI/" style="font-size: 1.13rem;">CtCI</a> <a href="/tags/English/" style="font-size: 0.75rem;">English</a> <a href="/tags/Essay/" style="font-size: 1.13rem;">Essay</a> <a href="/tags/FP/" style="font-size: 0.75rem;">FP</a> <a href="/tags/JS/" style="font-size: 0.75rem;">JS</a> <a href="/tags/Python/" style="font-size: 0.75rem;">Python</a> <a href="/tags/Rails/" style="font-size: 0.75rem;">Rails</a> <a href="/tags/React/" style="font-size: 1.13rem;">React</a> <a href="/tags/Ruby/" style="font-size: 1.5rem;">Ruby</a> <a href="/tags/node/" style="font-size: 0.75rem;">node</a></div></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Article/">Article</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CtCI/">CtCI</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Essay/">Essay</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rails/">Rails</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2018 Jeewhan<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><!--[if lt IE 10]><script src="/js/classList.min.js"></script><![endif]--><script src="/js/index.min.js"></script></body></html>